
DATA STRUCTURE
1)Fenwick tree
template <class T> class BIT {
    private:
        int size;
        vector<T> bit;

    public:
        BIT(int size) : size(size), bit(size + 1) {}

        void add(int ind, int val) {
            ind++;
            for (; ind <= size; ind += ind & -ind) { bit[ind - 1] += val; }
        }

        T pref_sum(int ind) {
            ind++;
            T total = 0;
            for (; ind > 0; ind -= ind & -ind) { total += bit[ind - 1]; }
            return total;
        }

        T sumlr(int l, int r) {
            if (l == 0)
                return pref_sum(r);
            return pref_sum(r) - pref_sum(l - 1);
        }
};

2)Segment tree
template <class T> class SegTree {
    private:
        const T DEFAULT = 0;

        vector<T> segtree;
        int sz;
    public:
        SegTree(int len) : sz(len), segtree(2 * len, DEFAULT) {}

        void set(int idx, T val) {
            idx += sz;
            segtree[idx] = val;
            for (;idx > 1; idx >>= 1) {
                segtree[idx >> 1] = segtree[idx] + segtree[idx ^ 1];
            }
        }

        T get(int l, int r) { // [l, r)
            T ans = DEFAULT;
            for (l += sz, r += sz; l < r; l >>= 1, r >>= 1) {
                if (l & 1)
                    ans += segtree[l++];
                if (r & 1)
                    ans += segtree[--r];
            }
            return ans;
        }

        T operator [] (int idx) {
            return segtree[idx + sz];
        }
};
3)Lazy segtree
struct node
{
    int val = 0;
    int lz = 0;
};

vector<node> a;

void pushDown(int idx) {
    a[idx * 2].lz += a[idx].lz;
    a[idx * 2 + 1].lz += a[idx].lz;
    a[idx * 2].val += a[idx].lz;
    a[idx * 2 + 1].val += a[idx].lz;

    a[idx].lz = 0;
}

void upd(int idx, int l, int r, int u, int v, int val) {
    if (r < u || l > v) {
        return;
    }
    if (l >= u && r <= v) {
        a[idx].lz += val;
        a[idx].val += val;
        return;
    }
    pushDown(idx);
    upd(idx * 2, l, (l + r) / 2, u, v, val);
    upd(idx * 2 + 1, (l + r) / 2 + 1, r, u, v, val);
    a[idx].val = max(a[idx * 2].val, a[idx * 2 + 1].val);
}

int get(int idx, int l, int r, int u, int v) {
    if (r < u || l > v) {
        return -1e9;
    }
    if (l >= u && r <= v) {
        return a[idx].val;
    }
    pushDown(idx);
    int mid = (l + r) / 2;
    return max(get(2 * idx, l, mid, u, v), get(2 * idx + 1, mid + 1, r, u, v));
}

4)Sparse table
template<typename T, bool maximum_mode = false>
struct RMQ {
    static int highest_bit(unsigned x) {
        return x == 0 ? -1 : 31 - __builtin_clz(x);
    }
 
    int n = 0;
    vector<T> values;
    vector<vector<int>> range_low;
 
    RMQ(const vector<T> &_values = {}) {
        if (!_values.empty())
            build(_values);
    }
 
    // Note: when `values[a] == values[b]`, returns b.
    int better_index(int a, int b) const {
        return (maximum_mode ? values[b] < values[a] : values[a] < values[b]) ? a : b;
    }
 
    void build(const vector<T> &_values) {
        values = _values;
        n = int(values.size());
        int levels = highest_bit(n) + 1;
        range_low.resize(levels);
 
        for (int k = 0; k < levels; k++)
            range_low[k].resize(n - (1 << k) + 1);
 
        for (int i = 0; i < n; i++)
            range_low[0][i] = i;
 
        for (int k = 1; k < levels; k++)
            for (int i = 0; i <= n - (1 << k); i++)
                range_low[k][i] = better_index(range_low[k - 1][i], range_low[k - 1][i + (1 << (k - 1))]);
    }
 
    // Note: breaks ties by choosing the largest index.
    // Note: Range of all query is in [lf, rt)
    int query_index(int a, int b) const {
        assert(0 <= a && a < b && b <= n);
        int level = highest_bit(b - a);
        return better_index(range_low[level][a], range_low[level][b - (1 << level)]);
    }
    
    T query_value(int a, int b) const { 
        return values[query_index(a, b)];
    }
};

5)DSU
#line 2 "DS/DSU.hpp"
struct DSU {
    vector<int> e; void init(int N) { e = vector<int>(N,-1); }
    int get(int x) { return e[x] < 0 ? x : e[x] = get(e[x]); } 
    bool same(int a, int b) { return get(a) == get(b); }
    int size(int x) { return -e[get(x)]; }
    bool unite(int x, int y) { // union by size
        x = get(x), y = get(y); if (x == y) return 0;
        if (e[x] > e[y]) swap(x,y);
        e[x] += e[y]; e[y] = x; return 1;
    }
};

6)Mo queries+Mo on tree
void add(int ind, int end) { ... } // add a[ind] (end = 0 or 1)
void del(int ind, int end) { ... } // remove a[ind]
int calc() { ... } // compute current answer

vi mo(vector<pii> Q) {
    int L = 0, R = 0, blk = 350; // ~N/sqrt(Q)
    vi s(sz(Q)), res = s;
#define K(x) pii(x.first/blk, x.second ^ -(x.first/blk & 1))
    iota(all(s), 0);
    sort(all(s), [&](int s, int t){ return K(Q[s]) < K(Q[t]); });
    for (int qi : s) {
        pii q = Q[qi];
        while (L > q.first) add(--L, 0);
        while (R < q.second) add(R++, 1);
        while (L < q.first) del(L++, 0);
        while (R > q.second) del(--R, 1);
        res[qi] = calc();
    }
    return res;
}
vi moTree(vector<array<int, 2>> Q, vector<vi>& ed, int root=0){
    int N = sz(ed), pos[2] = {}, blk = 350; // ~N/sqrt(Q)
    vi s(sz(Q)), res = s, I(N), L(N), R(N), in(N), par(N);
    add(0, 0), in[0] = 1;
    auto dfs = [&](int x, int p, int dep, auto& f) -> void {
        par[x] = p;
        L[x] = N;
        if (dep) I[x] = N++;
        for (int y : ed[x]) if (y != p) f(y, x, !dep, f);
        if (!dep) I[x] = N++;
        R[x] = N;
    };
    dfs(root, -1, 0, dfs);
#define K(x) pii(I[x[0]] / blk, I[x[1]] ^ -(I[x[0]] / blk & 1))
    iota(all(s), 0);
    sort(all(s), [&](int s, int t){ return K(Q[s]) < K(Q[t]); });
    for (int qi : s) rep(end,0,2) {
        int &a = pos[end], b = Q[qi][end], i = 0;
#define step(c) { if (in[c]) { del(a, end); in[a] = 0; } \
                  else { add(c, end); in[c] = 1; } a = c; }
        while (!(L[b] <= L[a] && R[a] <= R[b]))
            I[i++] = b, b = par[b];
        while (a != b) step(par[a]);
        while (i--) step(I[i]);
        if (end) res[qi] = calc();
    }
    return res;
}

7)Treap
// Description: Easy BBST. Use split and merge to implement insert and delete.
using pt = struct tnode*;
struct tnode {
    int pri, val; pt c[2]; // essential
    int sz; ll sum; // for range queries
    bool flip = 0; // lazy update
    tnode(int _val) {
        pri = rng(); sum = val = _val; 
        sz = 1; c[0] = c[1] = nullptr;
    }
    ~tnode() { F0R(i,2) delete c[i]; } /// assume no sharing of data
};
int getsz(pt x) { return x?x->sz:0; }
ll getsum(pt x) { return x?x->sum:0; }
pt prop(pt x) { // lazy propagation
    if (!x || !x->flip) return x;   
    swap(x->c[0],x->c[1]);
    x->flip = 0; F0R(i,2) if (x->c[i]) x->c[i]->flip ^= 1;
    return x;
}
pt calc(pt x) {
    pt a = x->c[0], b = x->c[1];
    assert(!x->flip); prop(a), prop(b);
    x->sz = 1+getsz(a)+getsz(b);
    x->sum = x->val+getsum(a)+getsum(b);
    return x;
}
void tour(pt x, vi& v) { // print values of nodes, 
    if (!x) return; // inorder traversal
    prop(x); tour(x->c[0],v); v.pb(x->val); tour(x->c[1],v);
}
pair<pt,pt> split(pt t, int v) { // >= v goes to the right
    if (!t) return {t,t};
    prop(t);
    if (t->val >= v) {
        auto p = split(t->c[0], v); t->c[0] = p.s;
        return {p.f,calc(t)};
    } else {
        auto p = split(t->c[1], v); t->c[1] = p.f;
        return {calc(t),p.s};
    }
}
pair<pt,pt> splitsz(pt t, int sz) { // sz nodes go to left
    if (!t) return {t,t};
    prop(t);
    if (getsz(t->c[0]) >= sz) {
        auto p = splitsz(t->c[0],sz); t->c[0] = p.s;
        return {p.f,calc(t)};
    } else {
        auto p=splitsz(t->c[1],sz-getsz(t->c[0])-1); t->c[1]=p.f;
        return {calc(t),p.s};
    }
}
pt merge(pt l, pt r) { //  keys in l < keys in r
    if (!l || !r) return l?:r;
    prop(l), prop(r); pt t;
    if (l->pri > r->pri) l->c[1] = merge(l->c[1],r), t = l;
    else r->c[0] = merge(l,r->c[0]), t = r;
    return calc(t);
}
pt ins(pt x, int v) { // insert v
    auto a = split(x,v), b = split(a.s,v+1);
    return merge(a.f,merge(new tnode(v),b.s)); }
pt del(pt x, int v) { // delete v
    auto a = split(x,v), b = split(a.s,v+1);
    return merge(a.f,b.s); }

8)faster hashmap 
#include<bits/stdc++.h>
// #include<bits/extc++.h>
#include <ext/pb_ds/assoc_container.hpp>

struct splitmix64_hash {
    static uint64_t splitmix64(uint64_t x) {
        // http://xorshift.di.unimi.it/splitmix64.c
        x += 0x9e3779b97f4a7c15;
        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;
        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;
        return x ^ (x >> 31);
    }

    size_t operator()(uint64_t x) const {
        static const uint64_t FIXED_RANDOM = std::chrono::steady_clock::now().time_since_epoch().count();
        return splitmix64(x + FIXED_RANDOM);
    }
};

template <typename K, typename V, typename Hash = splitmix64_hash>
using hash_map = __gnu_pbds::gp_hash_table<K, V, Hash>;

template <typename K, typename Hash = splitmix64_hash>
using hash_set = hash_map<K, __gnu_pbds::null_type, Hash>;

9)PBDS 
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
using namespace __gnu_pbds;
typedef tree<int,null_type,less<int>,rb_tree_tag,tree_order_statistics_node_update> ods;
// - insert(x),erase(x)
// - find_by_order(k): return iterator to the k-th smallest element
// - order_of_key(x): the number of elements that are strictly smaller


10)DSU rollback
// 0-based
// DSU with rollback {{{
struct Data {
    int time, u, par;  // before `time`, `par` = par[u]
};

struct DSU {
    vector<int> par;
    vector<Data> change;

    DSU(int n) : par(n + 5, -1) {}

    // find root of x.
    // if par[x] < 0 then x is a root, and its tree has -par[x] nodes
    int getRoot(int x) {
        while (par[x] >= 0)
            x = par[x];
        return x;
    }

    bool same_component(int u, int v) {
        return getRoot(u) == getRoot(v);
    }

    // join components containing x and y.
    // t should be current time. We use it to update `change`.
    bool join(int x, int y, int t) {
        x = getRoot(x);
        y = getRoot(y);
        if (x == y) return false;

        //union by rank
        if (par[x] < par[y]) swap(x, y); 
        //now x's tree has less nodes than y's tree
        change.push_back({t, y, par[y]});
        par[y] += par[x];
        change.push_back({t, x, par[x]});
        par[x] = y;
        return true;
    }

    // rollback all changes at time > t.
    void rollback(int t) {
        while (!change.empty() && change.back().time > t) {
            par[change.back().u] = change.back().par;
            change.pop_back();
        }
    }
};
// }}}

11) Hash table
const int P = 1e6 + 3;

struct HashTable {
    vector< pair<int,int> > h[P];

public:
    void insert(int key, int value) {
        int hkey = getHash(key);
        for (auto p : h[hkey]) {
            if (p.first == key) {
                // key da ton tai trong Hash table, ta bo qua
                return;
            }
        }
        // Them (key, value) vao hash table
        h[hkey].emplace_back(key, value);
    }

    int find(int key) {
        int hkey = getHash(key);
        for(auto p : h[hkey]) {
            if (p.first == key) {
                // ton tai key trong Hash table, return value
                return p.value;
            }
        }
        // Khong tim thay
        return 0;
    }

private:
    int getHash(int key) {
        // Cho 1 key, tra lai Hash value la key % P
        return key % P;
    }
};

+)NOTE:
RTE:
-check for memories. Check for if we do something outside range of vector.Any possible division by 0(mod 0).Infinite recursion ?
TLE:
-Check for infinite loops ?
-Reduce time complexity
-Avoid vector,map try to use unorderedmap or array if it can use 
MLE:
-think of max amount of memory your algorithm will use.
 
12)sqrt decomposition
SQ 
int SZ;
 
struct Block {
    int l, r, id;
    Block(int l, int r, int id) : l(l), r(r), id(id) {}
    bool operator < (const Block & other) const {
        if((l / SZ) != (other.l / SZ)) return (l < other.l);
        return (r < other.r);
    }
};



GRAPH THEORY
I)Graph
1)Bridge and cut vertex
int time = 0;
vector<int> st(n), low(n);
vector<bool> vis(n);
int cau = 0, khop = 0;
function<void(int, int)> dfs =[&](int u, int p) {
    st[u] = time++;
    vis[u] = true;
    low[u] = st[u];
    int cnt = p != -1;
    for (auto v : g[u]) {
        if (v == p) continue;
        if (vis[v]) ckmin(low[u], st[v]);
        else {
            dfs(v, u);
            ckmin(low[u], low[v]);
            if (low[v] == st[v]) cau++;
            if (low[v] >= st[u]) cnt++;
        }
    }
    khop += cnt > 1;
};

2)SCC
#include <bits/stdc++.h>

using namespace std;

const int maxN = 100010;

int n, m;
int timeDfs = 0, scc = 0;
int low[maxN], num[maxN];
bool deleted[maxN];
vector <int> g[maxN];
stack <int> st;

void dfs(int u) {
    num[u] = low[u] = ++timeDfs;
    st.push(u);
    for (int v : g[u]) {
      if (deleted[v]) continue;
        if (!num[v]){
            dfs(v);
            low[u] = min(low[u], low[v]);
        }
        else low[u] = min(low[u], num[v]);
    }
    if (low[u] == num[u]) {
        scc++;
        int v;
        do {
            v = st.top();
            st.pop();
            deleted[v] = true;
        }
        while (v != u);
    }
}

int main() {
    cin >> n >> m;
    for (int i = 1; i <= m; i++) {
        int u, v;
        cin >> u >> v;
        g[u].push_back(v);
    }
    for (int i = 1; i <= n; i++)
        if (!num[i]) dfs(i);

    cout << scc;
}

3)BCC

// Input graph: vector< vector<int> > a, int n
// Note: 0-indexed
// Usage: BiconnectedComponent bc; (bc.components is the list of components)
//
// This is biconnected components by edges (1 vertex can belong to
// multiple components). For vertices biconnected component, remove
// bridges and find components
int n;
vector<vector<int>> g;
struct BiconnectedComponent {
    vector<int> low, num, s;
    vector< vector<int> > components;
    int counter;
    BiconnectedComponent() : low(n, -1), num(n, -1), counter(0) {
        for (int i = 0; i < n; i++)
            if (num[i] < 0)
                dfs(i, 1);
    }
    void dfs(int x, int isRoot) {
        low[x] = num[x] = ++counter;
        if (g[x].empty()) {
            components.push_back(vector<int>(1, x));
            return;
        }
        s.push_back(x);	
        for (int i = 0; i < (int) g[x].size(); i++) {
            int y = g[x][i];
            if (num[y] > -1) low[x] = min(low[x], num[y]);
            else {
                dfs(y, 0);
                low[x] = min(low[x], low[y]);

                if (isRoot || low[y] >= num[x]) {
                    components.push_back(vector<int>(1, x));
                    while (1) {
                        int u = s.back();
                        s.pop_back();
                        components.back().push_back(u);
                        if (u == y) break;
                    }
                }
            }
        }
    }
};

4)Euler path
/*
  referenece MIT notebook
*/
template<bool directed>
struct Euler {
    int N;                          
    std::vector<std::vector<std::pair<int, int>>> adj;   
    std::vector<std::vector<std::pair<int, int>>::iterator> its; 
    std::vector<bool> used;
    void init(int _N) {N = _N; adj.resize(N);}
    void add_edge(int a, int b) {
        int M = used.size();     
        used.push_back(false);   
        adj[a].emplace_back(b, M);   
        if (!directed) {adj[b].emplace_back(a, M);}
    }
    std::vector<std::pair<int, int>> solve(int src = 0) {
        its.resize(N);   
        for (int i = 0; i < N; ++i){its[i] = adj[i].begin();}
        std::vector<std::pair<int, int>> ans,s{{src, -1}}; 
        int last = -1; 
        while (!s.empty()) {
            int x = s.back().first;  
            auto& it = its[x];       
            auto en = adj[x].end(); 
            while (it != en && used[it->second]) {++it;}
            if (it == en) {
                if (last != -1 && last != x) {return {};}
                ans.push_back(s.back());  
                s.pop_back(); 
                if (!s.empty()) {
                    last = s.back().first;  
                }
            } else {
                s.push_back(*it);
                used[it->second] = true; 
            }
        }
        if (ans.size() != used.size() + 1) {return {};}
        std::reverse(ans.begin(), ans.end());
        return ans;  
    }
};


5) Topo sort
vector<int> topoSort(const vector<vector<int>>& gr) {
    vector<int> indeg(sz(gr)), ret;
    for (auto& li : gr) for (int x : li) indeg[x]++;
    queue<int> q; // use priority_queue for lexic. largest ans.
    rep(i,0,sz(gr)) if (indeg[i] == 0) q.push(i);
    while (!q.empty()) {
        int i = q.front(); // top() for priority queue
        ret.push_back(i);
        q.pop();
        for (int x : gr[i])
            if (--indeg[x] == 0) q.push(x);
    }
    return ret;
}

6)Dijkstra
const long long INF = 2000000000000000000LL;
struct Edge{
    int v;
    long long w;
};
void dijkstra(int n, int S, vector<vector<Edge>> E, vector<long long> &D, vector<int> &trace) {
    D.resize(n, INF);
    trace.resize(n, -1);
    vector<bool> P(n, 0);
    D[S] = 0;
    for (int i = 0; i < n; i++) {
        int uBest; // tìm đỉnh u chưa dùng, có khoảng cách nhỏ nhất
        long long Max = INF;
        for (int u = 0; u < n; u++) {
            if(D[u] < Max && P[u] == false) {
                uBest = u;
                Max = D[u];
            }
        }
        // cải tiến các đường đi qua u
        int u = uBest;
        P[u] = true;
        for(auto x : E[u]) {
            int v = x.v;
            long long w = x.w;
            if(D[v] > D[u] + w) {
                D[v] = D[u] + w;
                trace[v] = u;
            }
        }
    }
}




7)Bellman ford+ check negative cycle
const long long INF = 2000000000000000000LL;
struct Edge {
    int u, v;
    long long w; // cạnh từ u đến v, trọng số w
};
void bellmanFord(int n, int S, vector<Edge> &e, vector<long long> &D, vector<int> &trace) {
    // e: danh sách cạnh
    // n: số đỉnh
    // S: đỉnh bắt đầu
    // D: độ dài đường đi ngắn nhất
    // trace: mảng truy vết đường đi
    // INF nếu không có đường đi
    // -INF nếu có đường đi âm vô tận
    D.resize(n, INF);
    trace.resize(n, -1);
    D[S] = 0;
    for(int T = 1; T < n; T++) {
        for (auto E : e) {
            int u = E.u;
            int v = E.v;
            long long w = E.w;
            if (D[u] != INF && D[v] > D[u] + w) {
                D[v] = D[u] + w;
                trace[v] = u;
            }
        }
    }
}
//check negative cycle
bool findNegativeCycle(int n, vector<long long> &D, vector<int> &trace, vector<int> &negCycle) {
    // mảng D và trace đã được chạy qua thuật toán Bellman-Ford
    int negStart = -1; // đỉnh bắt đầu
    for (auto E : e) {
        int u = E.u;
        int v = E.v;
        long long w = E.w;
        if (D[u] != INF && D[v] > D[u] + w) {
            D[v] = -INF;
            trace[v] = u;
            negStart = v; // đã tìm thấy -INF
        }
    }
    if (negStart == -1) return false; // không có chu trình âm
    int u = negStart;
    for (int i = 0; i < n; i++) {
        u = trace[u]; // đưa u về chu trình âm
    }
    negCycle = vector<int>(1, u);
    for (int v = trace[u]; v != u; v = trace[u]) {
        negCycle.push_back(v); // truy vết một vòng
    }
    reverse(negCycle.begin(), negCycle.end());
    return true;
}	

8)BFS 0-1
/*
 reference: VNOI WIKI
*/
const int INF = 1e9;
const int MAXN = 2e6+5;
int n; // Số đỉnh của đồ thị
int D[MAXN], vis[MAXN];
vector<pair<int, int>> g[MAXN];  // first là đầu mút của cạnh, second là trọng số của cạnh
deque<int> dq;
void BFS_01(int s){
    for(int i = 1; i <= n; i++){
        D[i] = INF;              // Khởi tạo
        vis[i] = 0;
    }
    D[s] = 0;
    dq.push_front(s);
    while(!dq.empty()){
        int u = dq.front();
        dq.pop_front();
        if(vis[u])continue;
        vis[u] = 1;             // Đánh dấu
        for(auto v: g[u]){
            if(D[v.first] > D[u] + v.second){              //
                D[v.first] = D[u] + v.second;              // Duyệt và sử lý các cạnh của u
                if(v.second == 1)dq.push_back(v.first);    //
                else dq.push_front(v.first);
            }
        }
    }
}

9)MST
// MST. 0-based index
//
// Returns:
// {mst cost, edges in mst}
//
// If graph is not connected, returns forest (number of edges will be < n-1)

#include "../DataStructure/DSU/DisjointSet.h"
// MST {{{
using ll = long long;
template<typename EdgeT>
std::pair<ll, std::vector<EdgeT>> mst(
        int n,
        std::vector<EdgeT> edges) {
    std::sort(edges.begin(), edges.end());

    DSU dsu(n + 1);  // tolerate 1-based index
    ll total = 0;
    vector<EdgeT> tree;
    for (const auto& e : edges) {
        if (dsu.merge(e.u, e.v)) {
            total += e.c;
            tree.push_back(e);
        }
    }
    return {total, tree};
}
struct Edge {
    int u, v;
    ll c;
};
bool operator < (const Edge& a, const Edge& b) {
    return a.c < b.c;
}
ostream& operator << (ostream& out, const Edge& e) {
    out << e.u << " - " << e.v << " [" << e.c << ']';
    return out;
}
// }}}

10) Max flow(Dinic)
struct Dinic {
    using F = long long; // flow type
    struct Edge { int to; F flo, cap; };
    int N; std::vector<Edge> eds; std::vector<std::vector<int>> adj;
    void init(int _N) { N = _N; adj.resize(N), cur.resize(N); }
    /// void reset() { for(auto& e : eds) e.flo = 0; }
    void ae(int u, int v, F cap, F rcap = 0) { assert(std::min(cap,rcap) >= 0); 
        adj[u].push_back(eds.size()); eds.push_back({v,0,cap});
        adj[v].push_back(eds.size()); eds.push_back({u,0,rcap});
    }
    std::vector<int> lev; std::vector<std::vector<int>::iterator> cur;
    bool bfs(int s, int t) { // level = shortest distance from source
        lev = std::vector<int>(N,-1); for(int i = 0; i < N; ++i) cur[i] = begin(adj[i]);
        std::queue<int> q({s}); lev[s] = 0; 
        while (!q.empty()) { int u = q.front(); q.pop();
            for(auto e : adj[u]) { const Edge& E = eds[e];
                int v = E.to; if (lev[v] < 0 && E.flo < E.cap) 
                    q.push(v), lev[v] = lev[u]+1;
            }
        }
        return lev[t] >= 0;
    }
    F dfs(int v, int t, F flo) {
        if (v == t) return flo;
        for (; cur[v] != end(adj[v]); cur[v]++) {
            Edge& E = eds[*cur[v]];
            if (lev[E.to] != lev[v] + 1 || E.flo == E.cap) continue;
            F df = dfs(E.to, t, std::min(flo, E.cap - E.flo));
            if (df) { E.flo += df; eds[*cur[v]^1].flo -= df;
                return df; } // saturated >=1 one edge
        }
        return 0;
    }
    F maxFlow(int s, int t) {
        F tot = 0; while (bfs(s,t)) while (F df = 
            dfs(s,t,std::numeric_limits<F>::max())) tot += df;
        return tot;
    }
};


11)MCMF
struct MCMF { 
    using F = ll; using C = ll; // flow type, cost type
    struct Edge { int to; F flo, cap; C cost; };
    int N; vector<C> p, dist; vector<int> pre; vector<Edge> eds; vector<vector<int>> adj;
    void init(int _N) { 
        N = _N;
        p.resize(N), dist.resize(N), pre.resize(N), adj.resize(N); 
    }
    void ae(int u, int v, F cap, C cost) { 
        assert(cap >= 0); 
        adj[u].push_back(eds.size()); 
        eds.push_back({v, 0, cap, cost}); 
        adj[v].push_back(eds.size()); 
        eds.push_back({u, 0, 0, -cost});
    } // use asserts, don't try something dumb
    bool path(int s, int t) { // find lowest cost path to send flow through
        const C inf = numeric_limits<C>::max(); 
        for (int i = 0; i < N; i++) dist[i] = inf;
        using T = pair<C, int>; 
        priority_queue<T, vector<T>, greater<T>> todo; 
        todo.push({dist[s] = 0, s}); 
        while (!todo.empty()) { // Dijkstra
            T x = todo.top(); 
            todo.pop(); 
            if (x.first > dist[x.second]) continue;
            for (auto e : adj[x.second]) { 
                const Edge& E = eds[e]; // all weights should be non-negative
                if (E.flo < E.cap && dist[E.to] > x.first + E.cost + p[x.second] - p[E.to]) {
                    dist[E.to] = x.first + E.cost + p[x.second] - p[E.to];
                    pre[E.to] = e; 
                    todo.push({dist[E.to], E.to});
                }
            }
        }
        return dist[t] != inf; // return flow
    }
    pair<F,C> calc(int s, int t) { 
        assert(s != t);
        for (int _ = 0; _ < N; _++) 
            for (int e = 0; e < eds.size(); e++) { 
                const Edge& E = eds[e]; // Bellman-Ford
                if (E.cap) p[E.to] = min(p[E.to], p[eds[e^1].to] + E.cost); 
            }
        F totFlow = 0; C totCost = 0;
        while (path(s, t)) { // p -> potentials for Dijkstra
            for (int i = 0; i < N; i++) p[i] += dist[i]; // don't matter for unreachable nodes
            F df = numeric_limits<F>::max();
            for (int x = t; x != s; x = eds[pre[x]^1].to) {
                const Edge& E = eds[pre[x]]; 
                df = min(df, E.cap - E.flo); 
            }
            totFlow += df; 
            totCost += (p[t] - p[s]) * df;
            for (int x = t; x != s; x = eds[pre[x]^1].to) {
                eds[pre[x]].flo += df; 
                eds[pre[x]^1].flo -= df;
            }
        } // get max flow you can send along path
        return {totFlow, totCost};
    }
};

12)Bipartite matching
// Max Bipartite matching.
// Index from 0
// Assume 2 sides have same number of vertices
//
// Notes:
// - If TLE --> try shuffle edges
//   REP(i,n) shuffle(ke[i].begin(), ke[i].end(), rng)
// - It should be quite fast, can AC 10^5 vertices
//
// Find vertices that belong to all maximum matching:
// (see https://codeforces.com/gym/100337/submission/139751832)
// - L = vertices not matched on left side --> BFS from these vertices
//   (left --> right: unmatched edges, right --> left: matched edges)
//   reachable vertices on left side --> not belong to some maximum matching
// - Do similar for right side
//
// Bipartite Matching {{{
struct Matching {
    int n;
    vector< vector<int> > ke;
    vector< int > seen;
    vector< int > matchL, matchR;
    int iteration;
    Matching(int _n) : n(_n), ke(_n), seen(_n, false), matchL(_n, -1), matchR(_n, -1), iteration{0} {
    }
    void addEdge(int u, int v) {
        ke[u].push_back(v);
    }
    bool dfs(int u) {
        seen[u] = iteration;
        for (int v : ke[u]) {
            if (matchR[v] < 0) {
                matchR[v] = u;
                matchL[u] = v;
                return true;
            }
        }
        for (int v : ke[u]) {
            if (seen[matchR[v]] != iteration && dfs(matchR[v])) {
                matchR[v] = u;
                matchL[u] = v;
                return true;
            }
        }
        return false;
    }
    int match() {
        int res = 0;
        int newMatches = 0;
        do {
            iteration++;
            newMatches = 0;
            for (int u = 0; u < n; u++) {
                if (matchL[u] < 0 && dfs(u)) ++newMatches;
            }
            res += newMatches;
        } while (newMatches > 0);
        return res;
    }
};
// }}}

13)Hungarian
/**
 * Description: Given J jobs and W workers (J <= W), computes the minimum cost
 * to assign each prefix of jobs to distinct workers.
 *
 * @tparam T a type large enough to represent integers on the order of J *
 * max(|C|)
 * @param C a matrix of dimensions JxW such that C[j][w] = cost to assign j-th
 * job to w-th worker (possibly negative)
 *
 * @return a vector of length J, with the j-th entry equaling the minimum cost
 * to assign the first (j+1) jobs to distinct workers
 * Time: O(J^2W)
 */
template <class T> vector<T> hungarian(const vector<vector<T>> &C) {
    const int J = (int)size(C), W = (int)size(C[0]);
    assert(J <= W);
    /// job[w] = job assigned to w-th worker, or -1 if no job assigned
    /// note: a W-th worker was added for convenience
    vector<int> job(W + 1, -1);
    vector<T> ys(J), yt(W + 1); /// potentials
    /// -yt[W] will equal the sum of all deltas
    vector<T> answers;
    const T inf = numeric_limits<T>::max();
    for (int j_cur = 0; j_cur < J; ++j_cur) { /// assign j_cur-th job
        int w_cur = W;
        job[w_cur] = j_cur;
        /// min reduced cost over edges from Z to worker w
        vector<T> min_to(W + 1, inf);
        vector<int> prv(W + 1, -1); /// previous worker on alternating path
        vector<bool> in_Z(W + 1);   /// whether worker is in Z
        while (job[w_cur] != -1) {  /// runs at most j_cur + 1 times
            in_Z[w_cur] = true;
            const int j = job[w_cur];
            T delta = inf;
            int w_next;
            for (int w = 0; w < W; ++w) {
                if (!in_Z[w]) {
                    if (ckmin(min_to[w], C[j][w] - ys[j] - yt[w]))
                        prv[w] = w_cur;
                    if (ckmin(delta, min_to[w])) w_next = w;
                }
            }
            /// delta will always be non-negative,
            /// except possibly during the first time this loop runs
            /// if any entries of C[j_cur] are negative
            for (int w = 0; w <= W; ++w) {
                if (in_Z[w]) ys[job[w]] += delta, yt[w] -= delta;
                else min_to[w] -= delta;
            }
            w_cur = w_next;
        }
        /// update assignments along alternating path
        for (int w; w_cur != -1; w_cur = w) job[w_cur] = job[w = prv[w_cur]];
        answers.push_back(-yt[W]);
    }
    return answers;
}

14)LCA-RMQ
#include<DS/Sparse table>
struct LCA {
    int T = 0;
    vi time, path, ret;
    RMQ<int> rmq;

    LCA(vector<vi>& C) : time(sz(C)), rmq((dfs(C,0,-1), ret)) {}
    void dfs(vector<vi>& C, int v, int par) {
        time[v] = T++;
        for (int y : C[v]) if (y != par) {
            path.push_back(v), ret.push_back(time[v]);
            dfs(C, y, v);
        }
    }

    int lca(int a, int b) {
        if (a == b) return a;
        tie(a, b) = minmax(time[a], time[b]);
        return path[rmq.query(a, b)];
    }
    //dist(a,b){return depth[a] + depth[b] - 2*depth[lca(a,b)];}
};

15)LCA normal
const int MAXN = 1005;
const int MAXLOG = 20;
vector<int> adj[MAXN];
int depth[MAXN];
int parent[MAXN][MAXLOG];
void dfs(int u) {
    for (int v : adj[u]) {
        if (v == parent[u][0]) continue;
        depth[v] = depth[u] + 1;
        parent[v][0] = u;
        for (int i = 1; i < MAXLOG; i++) {
            if (parent[v][i-1] != -1) {
                parent[v][i] = parent[parent[v][i-1]][i-1];
            }
        }
        dfs(v);
    }
} 
int jump(int u, int d){
    for (int i = 0; i < MAXLOG; i++) {
        if ((d >> i) & 1) {
            u = parent[u][i];
        }
    }
    return u;
}
int lca(int u, int v) {
    if (depth[u] < depth[v]) {
        swap(u, v);
    }
    u = jump(u, depth[u] - depth[v]);
    if (u == v) {return u;}
    for (int i = MAXLOG - 1; i >= 0; i--) {
        if (parent[u][i] != parent[v][i]) {
            u = parent[u][i];
            v = parent[v][i];
        }
    }
    return parent[u][0];
}

16) HLD
/*
   define suitable data structure here for HLD
*/
int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(0);
 
    #ifdef Debug
    freopen("in.txt", "r", stdin);
    freopen("out.txt", "w", stdout);
    #endif
    int n, m, cnt = 0; cin >> n >> m;
    vector<vi> g(n);
    vi a(n), id(n), par(n), dep(n), sz(n), top(n);
    SegTree<ll> st(n);
    REP(i, n) cin >> a[i];
    REP(i, n - 1) {
        int u, v; cin >> u >> v;
        u--, v--;
        g[u].PB(v);
        g[v].PB(u);
    }
    function<void(int, int)> dfs = [&](int u, int p) {
        sz[u] = 1;
        par[u] = p;
        for (auto v : g[u]) {
            if (v == p) continue;
            dep[v] = dep[u] + 1;
            dfs(v, u);
            sz[u] += sz[v];
        }
    };
    dfs(0, 0);
    function<void(int, int, int)> hld = [&](int u, int p, int tp) {
        id[u] = cnt++;
        st.set(id[u], a[u]);
        top[u] = tp;
        int mx = -1, idx_mx = -1;
        for (auto v : g[u]) {
            if (v == p) continue;
            if (ckmax(mx, sz[v])) idx_mx = v;
        }
        if (idx_mx == -1) return;
        hld(idx_mx, u, tp);
        for (auto v : g[u]) {
            if (v == p || v == idx_mx) continue;
            hld(v, u, v);
        }
    };
    hld(0, 0, 0);
    function<ll(int, int)> path = [&](int x, int y) {
        ll ans = 0;
        while(top[x] != top[y]) {
            if (dep[top[x]] < dep[top[y]]) swap(x, y);
            ckmax(ans, st.get(id[top[x]], id[x] + 1));
            x = par[top[x]];
        }
        if (id[x] > id[y]) swap(x, y);
        ckmax(ans, st.get(id[x], id[y] + 1));
        return ans;
    };
    dbg(id);
    REP(i, m) {
        int t, x, y; cin >> t >> x >> y;
        if (t == 1) {
            x--;
            st.set(id[x], y);
        }
        else {
            cout << path(x - 1, y - 1) << " ";
        }
    }
    return 0;
}

17)Centroid Decomposition
/*---code from bqi----*/
#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)
#define R0F(i,a) ROF(i,0,a)
#define rep(a) F0R(_,a)
#define each(a,x) for (auto& a: x)
void ad(vi& a, int b) { ckmin(b,sz(a)-1); if (b>=0) a[b]++; }
void prop(vi& a) { R0F(i,sz(a)-1) a[i] += a[i+1]; }
template<int SZ> struct Centroid {
    vi adj[SZ]; void ae(int a,int b){adj[a].pb(b),adj[b].pb(a);}
    bool done[SZ]; // processed as centroid yet
    int N,sub[SZ],cen[SZ],lev[SZ]; // subtree size, centroid anc
    int dist[32-__builtin_clz(SZ)][SZ]; // dists to all ancs
    vi stor[SZ], STOR[SZ];
    void dfs(int x, int p) { sub[x] = 1; 
        each(y,adj[x]) if (!done[y] && y != p) 
            dfs(y,x), sub[x] += sub[y]; 
    }
    int centroid(int x) {
        dfs(x,-1); 
        for (int sz = sub[x];;) {
            pi mx = {0,0};
            each(y,adj[x]) if (!done[y] && sub[y] < sub[x]) 
                ckmax(mx,{sub[y],y});
            if (mx.f*2 <= sz) return x; 
            x = mx.s;
        }
    }
    void genDist(int x, int p, int lev) {
        dist[lev][x] = dist[lev][p]+1;
        each(y,adj[x]) if (!done[y] && y != p) genDist(y,x,lev); }
    void gen(int CEN, int _x) { // CEN = centroid above x
        int x = centroid(_x); done[x] = 1; cen[x] = CEN; 
        sub[x] = sub[_x]; lev[x] = (CEN == -1 ? 0 : lev[CEN]+1);
        dist[lev[x]][x] = 0; 
        stor[x].rsz(sub[x]),STOR[x].rsz(sub[x]+1); 
        each(y,adj[x]) if (!done[y]) genDist(y,x,lev[x]);
        each(y,adj[x]) if (!done[y]) gen(x,y);
    }
    void init(int _N) { N = _N; FOR(i,1,N+1) done[i] = 0;
        gen(-1,1); } // start at vert 1
    void upd(int x, int y) { 
        int cur = x, pre = -1;
        R0F(i,lev[x]+1) {
            ad(stor[cur],y-dist[i][x]); 
            if (pre != -1) ad(STOR[pre],y-dist[i][x]);
            if (i > 0) pre = cur, cur = cen[cur];
        }
    } // call propAll() after all updates
    void propAll() { FOR(i,1,N+1) prop(stor[i]), prop(STOR[i]); }
    int query(int x) { // get value at vertex x
        int cur = x, pre = -1, ans = 0;
        R0F(i,lev[x]+1) { // if pre != -1, subtract those from
            ans += stor[cur][dist[i][x]]; // same subtree
            if (pre != -1) ans -= STOR[pre][dist[i][x]];
            if (i > 0) pre = cur, cur = cen[cur];
        }
        return ans;
    }
};
18)Link cut tree
struct Node { // Splay tree. Root's pp contains tree's parent.
    Node *p = 0, *pp = 0, *c[2];
    bool flip = 0;
    Node() { c[0] = c[1] = 0; fix(); }
    void fix() {
        if (c[0]) c[0]->p = this;
        if (c[1]) c[1]->p = this;
        // (+ update sum of subtree elements etc. if wanted)
    }
    void pushFlip() {
        if (!flip) return;
        flip = 0; swap(c[0], c[1]);
        if (c[0]) c[0]->flip ^= 1;
        if (c[1]) c[1]->flip ^= 1;
    }
    int up() { return p ? p->c[1] == this : -1; }
    void rot(int i, int b) {
        int h = i ^ b;
        Node *x = c[i], *y = b == 2 ? x : x->c[h], *z = b ? y : x;
        if ((y->p = p)) p->c[up()] = y;
        c[i] = z->c[i ^ 1];
        if (b < 2) {
            x->c[h] = y->c[h ^ 1];
            y->c[h ^ 1] = x;
        }
        z->c[i ^ 1] = this;
        fix(); x->fix(); y->fix();
        if (p) p->fix();
        swap(pp, y->pp);
    }
    void splay() { /// Splay this up to the root. Always finishes without flip set.
        for (pushFlip(); p; ) {
            if (p->p) p->p->pushFlip();
            p->pushFlip(); pushFlip();
            int c1 = up(), c2 = p->up();
            if (c2 == -1) p->rot(c1, 2);
            else p->p->rot(c2, c1 != c2);
        }
    }
    Node* first() { /// Return the min element of the subtree rooted at this, splayed to the top.
        pushFlip();
        return c[0] ? c[0]->first() : (splay(), this);
    }
};

struct LinkCut {
    vector<Node> node;
    LinkCut(int N) : node(N) {}

    void link(int u, int v) { // add an edge (u, v)
        assert(!connected(u, v));
        makeRoot(&node[u]);
        node[u].pp = &node[v];
    }
    void cut(int u, int v) { // remove an edge (u, v)
        Node *x = &node[u], *top = &node[v];
        makeRoot(top); x->splay();
        assert(top == (x->pp ?: x->c[0]));
        if (x->pp) x->pp = 0;
        else {
            x->c[0] = top->p = 0;
            x->fix();
        }
    }
    bool connected(int u, int v) { // are u, v in the same tree?
        Node* nu = access(&node[u])->first();
        return nu == access(&node[v])->first();
    }
    void makeRoot(Node* u) { /// Move u to root of represented tree.
        access(u);
        u->splay();
        if(u->c[0]) {
            u->c[0]->p = 0;
            u->c[0]->flip ^= 1;
            u->c[0]->pp = u;
            u->c[0] = 0;
            u->fix();
        }
    }
    Node* access(Node* u) { /// Move u to root aux tree. Return the root of the root aux tree.
        u->splay();
        while (Node* pp = u->pp) {
            pp->splay(); u->pp = 0;
            if (pp->c[1]) {
                pp->c[1]->p = 0; pp->c[1]->pp = pp; }
            pp->c[1] = u; pp->fix(); u = pp;
        }
        return u;
    }
};

19) K-Shortest walk
/*
 Description: For i from 1 to k(inclusive),output xi length of ith shortest-walk from vertex s to vertex t. if no walk output -1
*/
template <class T>
struct Node {
    static int get(Node *x) { return x ? x->d : 0; }
    static Node *merge(Node *x, Node *y) {
        if (!x) return y;
        if (!y) return x;
        if (x->key > y->key) swap(x, y);
        Node *res = new Node(*x);
        res->chr = merge(res->chr, y);
        if (get(res->chr) > get(res->chl)) swap(res->chl, res->chr);
        res->d = get(res->chr) + 1;
        return res;
    }
    int d;
    T key;
    Node *chl = nullptr, *chr = nullptr;
    Node(T key) : d(1), key(key) {}
};
 
template <typename T>
using MinHeap = priority_queue<T, vector<T>, greater<T>>;
 
vector<ll> k_shortest_paths(const vector<vector<pair<int, ll>>>& adj, int s, int t, int k) {
    int n = adj.size();
    MinHeap<pair<ll, int>> dq;
    vector<int> p(n, -1), order;
    vector<ll> d(n, -1);
    dq.emplace(d[s] = 0, s);
    while (!dq.empty()) {
        auto [du, u] = dq.top(); dq.pop();
        if (du != d[u]) continue;
        order.push_back(u);
        for (auto [v, w] : adj[u]) {
            if (d[v] == -1 or d[v] > d[u] + w) {
                p[v] = u;
                dq.emplace(d[v] = d[u] + w, v);
            }     
        }
    }
    vector<ll> res;
    if (d[t] == -1) return res;  // no path to t
    res.push_back(d[t]);
    vector<Node<pair<ll, int>>*> roots(n, nullptr);
    vector<int> mul(n, 0);
    for (int u = 0; u < n; u++) {
        if (d[u] == -1) continue;
        for (auto [v, w] : adj[u]) {
            if (d[v] == -1) continue;
            w += d[u] - d[v];
            if (p[v] != u or w or exchange(mul[v], 1))
                roots[v] = Node<pair<ll, int>>::merge(roots[v], new Node<pair<ll, int>>({w, u}));
        }
    }
    for (int u : order)
        if (u != s) roots[u] = Node<pair<ll, int>>::merge(roots[u], roots[p[u]]);
    if (!roots[t]) return res;
    MinHeap<pair<ll, Node<pair<ll, int>>*>> pq;
    pq.emplace(d[t] + roots[t]->key.first, roots[t]);
    while (!pq.empty() and (int)res.size() < k) {
        auto [cost, ptr] = pq.top(); pq.pop();
        res.push_back(cost);
        auto [w, v] = ptr->key;
        for (auto ch : {ptr->chl, ptr->chr}) {
            if (ch) pq.emplace(cost - w + ch->key.first, ch);
        }
        if (roots[v]) pq.emplace(cost + roots[v]->key.first, roots[v]);
    }
    return res;
}


20)2SAT
struct TwoSat {
    int N;
    vector<vi> gr;
    vi values; // 0 = false, 1 = true

    TwoSat(int n = 0) : N(n), gr(2*n) {}

    int addVar() { // (optional)
        gr.emplace_back();
        gr.emplace_back();
        return N++;
    }

    void either(int f, int j) {
        f = max(2*f, -1-2*f);
        j = max(2*j, -1-2*j);
        gr[f].push_back(j^1);
        gr[j].push_back(f^1);
    }
    void setValue(int x) { either(x, x); }

    void atMostOne(const vi& li) { // (optional)
        if (sz(li) <= 1) return;
        int cur = ~li[0];
        rep(i,2,sz(li)) {
            int next = addVar();
            either(cur, ~li[i]);
            either(cur, next);
            either(~li[i], next);
            cur = ~next;
        }
        either(cur, ~li[1]);
    }

    vi val, comp, z; int time = 0;
    int dfs(int i) {
        int low = val[i] = ++time, x; z.push_back(i);
        for(int e : gr[i]) if (!comp[e])
            low = min(low, val[e] ?: dfs(e));
        if (low == val[i]) do {
            x = z.back(); z.pop_back();
            comp[x] = low;
            if (values[x>>1] == -1)
                values[x>>1] = x&1;
        } while (x != i);
        return val[i] = low;
    }

    bool solve() {
        values.assign(N, -1);
        val.assign(2*N, 0); comp = val;
        rep(i,0,2*N) if (!comp[i]) dfs(i);
        rep(i,0,N) if (comp[2*i] == comp[2*i+1]) return 0;
        return 1;
    }
};

21)Tree diameter
using ll = long long;
pair<ll, vector<int>> tree_diameter(const vector<vector<pair<int,int>>>& g) {
    int n = g.size();
    vector<ll> dist(n);
    vector<int> parent(n);

    function<void(int, int, ll)> dfs = [&] (int u, int fu, ll cur_dist) {
        dist[u] = cur_dist;
        parent[u] = fu;
        for (auto [v, cost] : g[u]) if (v != fu) {
            dfs(v, u, cur_dist + cost);
        }
    };
    dfs(0, -1, 0);
    // r = furthest node from root
    int r = max_element(dist.begin(), dist.end()) - dist.begin();
    dfs(r, -1, 0);
    // r->s = longest path
    int s = max_element(dist.begin(), dist.end()) - dist.begin();

    vector<int> path;
    for (int x = s; x >= 0; x = parent[x]) path.push_back(x);

    return {dist[s], path};
}

22)small to large
/*
 * Complexity: O(NlogN)
 */
const int MAXN = 1e5 + 5;
int n;
vector<int> adj[MAXN];
int size[MAXN];
int lev[MAXN];
vector<int> *f[MAXN];
int cnt[MAXN];

void firstdfs(int u, int p) {
  size[u] = 1;
  for (int i = 0; i < (int)adj[u].size(); i++) {
    int v = adj[u][i];
    if (v != p) {
      lev[v] = lev[u] + 1;
      firstdfs(v, u);
      size[u] += size[v];
    }
  }
}

inline void add(int val) { cnt[val]++; }

inline void rem(int val) { cnt[val]--; }

void dfs(int u, int p, int keep) {
  pair<int, int> best;
  for (int i = 0; i < (int)adj[u].size(); i++) {
    int v = adj[u][i];
    if (v != p) {
      best = max(best, make_pair(size[v], v));
    }
  }
  for (int i = 0; i < (int)adj[u].size(); i++) {
    int v = adj[u][i];
    if (v != p && v != best.second) {
      dfs(v, u, 0);
    }
  }
  if (best.first) {
    dfs(best.second, u, 1);
    f[u] = f[best.second];
  } else {
    f[u] = new vector<int>;
  }
  // Getting answer from u
  f[u]->push_back(lev[u]);
  add(lev[u]);
  for (int i = 0; i < (int)adj[u].size(); i++) {
    int v = adj[u][i];
    if (v != p && v != best.second) {
      for (int j = 0; j < (int)f[v]->size(); j++) {
        int val = (*f[v])[j];
        // Getting answer from v
      }
      for (int j = 0; j < (int)f[v]->size(); j++) {
        int val = (*f[v])[j];
        f[u]->push_back(val);
        add(val);
      }
    }
  }
  if (!keep) {
    for (int i = 0; i < (int)f[u]->size(); i++) {
      int val = (*f[u])[i];
      rem(val);
    }
  }
}

STRING 
1)Hash string
const ll M = 1e9 + 9; // (1ll << 61) - 1
mt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count());
const ll B = uniform_int_distribution<ll>(311, M - 1)(rng);
class HashedString {
    private:
        vector<long long> pow;
        vector<long long> p_hash;
    public:
    HashedString(const string &s) : p_hash(s.size() + 1) {
        pow.push_back(1);
        while (pow.size() < s.size()) { pow.push_back((pow.back() * B) % M); }
        p_hash[0] = 0;
        for (int i = 0; i < s.size(); i++) {p_hash[i + 1] = ((p_hash[i] * B) % M + s[i]) % M;}
    }
    long long get_hash(int start, int end) {
        long long raw_val = (p_hash[end + 1] - (p_hash[start] * pow[end - start + 1]));
        return (raw_val % M + M) % M;
    }

}; 
2)KMP
// prefix function: *length* of longest prefix which is also suffix:
//   pi[i] = max(k: s[0..k-1] == s[i-(k-1)..i]
//
// KMP {{{
template<typename Container>
std::vector<int> prefix_function(const Container& s) {
    int n = s.size();
    std::vector<int> pi(n);
    for (int i = 1; i < n; ++i) {
        int j = pi[i-1];
        while (j > 0 && s[i] != s[j]) j = pi[j-1];
        if (s[i] == s[j]) ++j;
        pi[i] = j;
    }
    return pi;
}

// Tested: https://oj.vnoi.info/problem/substr
// Return all positions (0-based) that pattern `pat` appears in `text`
std::vector<int> kmp(const std::string& pat, const std::string& text) {
    auto pi = prefix_function(pat + '\0' + text);
    std::vector<int> res;
    for (size_t i = pi.size() - text.size(); i < pi.size(); ++i) {
        if (pi[i] == (int) pat.size()) {
            res.push_back(i - 2 * pat.size());
        }
    }
    return res;
}

// Tested: https://oj.vnoi.info/problem/icpc22_mt_b
// Returns cnt[i] = # occurrences of prefix of length-i
// NOTE: cnt[0] = n+1 (0-length prefix appears n+1 times)
std::vector<int> prefix_occurrences(const string& s) {
    int n = s.size();
    auto pi = prefix_function(s);
    std::vector<int> res(n + 1);
    for (int i = 0; i < n; ++i) res[pi[i]]++;
    for (int i = n-1; i > 0; --i) res[pi[i-1]] += res[i];
    for (int i = 0; i <= n; ++i) res[i]++;
    return res;
}
// }}}

3)Z function
#line 2 "String/Z_algorithm.hpp"
template <class T> std::vector<int> z_algorithm(const std::vector<T>& s) {
    int n = int(s.size());
    if (n == 0) return {};
    std::vector<int> z(n);
    z[0] = 0;
    for (int i = 1, j = 0; i < n; i++) {
        int& k = z[i];
        k = (j + z[j] <= i) ? 0 : std::min(j + z[j] - i, z[i - j]);
        while (i + k < n && s[k] == s[i + k]) k++;
        if (j + z[j] < i + z[i]) j = i;
    }
    z[0] = n;
    return z;
}

std::vector<int> z_algorithm(const std::string& s) {
    int n = int(s.size());
    std::vector<int> s2(n);
    for (int i = 0; i < n; i++) {
        s2[i] = s[i];
    }
    return z_algorithm(s2);
}

4) Suffix Array
std::vector<int> sa_naive(const std::vector<int>& s) {
    int n = int(s.size());
    std::vector<int> sa(n);
    std::iota(sa.begin(), sa.end(), 0);
    std::sort(sa.begin(), sa.end(), [&](int l, int r) {
        if (l == r) return false;
        while (l < n && r < n) {
            if (s[l] != s[r]) return s[l] < s[r];
            l++;
            r++;
        }
        return l == n;
    });
    return sa;
}

std::vector<int> sa_doubling(const std::vector<int>& s) {
    int n = int(s.size());
    std::vector<int> sa(n), rnk = s, tmp(n);
    std::iota(sa.begin(), sa.end(), 0);
    for (int k = 1; k < n; k *= 2) {
        auto cmp = [&](int x, int y) {
            if (rnk[x] != rnk[y]) return rnk[x] < rnk[y];
            int rx = x + k < n ? rnk[x + k] : -1;
            int ry = y + k < n ? rnk[y + k] : -1;
            return rx < ry;
        };
        std::sort(sa.begin(), sa.end(), cmp);
        tmp[sa[0]] = 0;
        for (int i = 1; i < n; i++) {
            tmp[sa[i]] = tmp[sa[i - 1]] + (cmp(sa[i - 1], sa[i]) ? 1 : 0);
        }
        std::swap(tmp, rnk);
    }
    return sa;
}

// SA-IS, linear-time suffix array construction
// Reference:
// G. Nong, S. Zhang, and W. H. Chan,
// Two Efficient Algorithms for Linear Time Suffix Array Construction
template <int THRESHOLD_NAIVE = 10, int THRESHOLD_DOUBLING = 40>
std::vector<int> sa_is(const std::vector<int>& s, int upper) {
    int n = int(s.size());
    if (n == 0) return {};
    if (n == 1) return {0};
    if (n == 2) {
        if (s[0] < s[1]) {
            return {0, 1};
        } else {
            return {1, 0};
        }
    }
    if (n < THRESHOLD_NAIVE) {
        return sa_naive(s);
    }
    if (n < THRESHOLD_DOUBLING) {
        return sa_doubling(s);
    }

    std::vector<int> sa(n);
    std::vector<bool> ls(n);
    for (int i = n - 2; i >= 0; i--) {
        ls[i] = (s[i] == s[i + 1]) ? ls[i + 1] : (s[i] < s[i + 1]);
    }
    std::vector<int> sum_l(upper + 1), sum_s(upper + 1);
    for (int i = 0; i < n; i++) {
        if (!ls[i]) {
            sum_s[s[i]]++;
        } else {
            sum_l[s[i] + 1]++;
        }
    }
    for (int i = 0; i <= upper; i++) {
        sum_s[i] += sum_l[i];
        if (i < upper) sum_l[i + 1] += sum_s[i];
    }

    auto induce = [&](const std::vector<int>& lms) {
        std::fill(sa.begin(), sa.end(), -1);
        std::vector<int> buf(upper + 1);
        std::copy(sum_s.begin(), sum_s.end(), buf.begin());
        for (auto d : lms) {
            if (d == n) continue;
            sa[buf[s[d]]++] = d;
        }
        std::copy(sum_l.begin(), sum_l.end(), buf.begin());
        sa[buf[s[n - 1]]++] = n - 1;
        for (int i = 0; i < n; i++) {
            int v = sa[i];
            if (v >= 1 && !ls[v - 1]) {
                sa[buf[s[v - 1]]++] = v - 1;
            }
        }
        std::copy(sum_l.begin(), sum_l.end(), buf.begin());
        for (int i = n - 1; i >= 0; i--) {
            int v = sa[i];
            if (v >= 1 && ls[v - 1]) {
                sa[--buf[s[v - 1] + 1]] = v - 1;
            }
        }
    };

    std::vector<int> lms_map(n + 1, -1);
    int m = 0;
    for (int i = 1; i < n; i++) {
        if (!ls[i - 1] && ls[i]) {
            lms_map[i] = m++;
        }
    }
    std::vector<int> lms;
    lms.reserve(m);
    for (int i = 1; i < n; i++) {
        if (!ls[i - 1] && ls[i]) {
            lms.push_back(i);
        }
    }

    induce(lms);

    if (m) {
        std::vector<int> sorted_lms;
        sorted_lms.reserve(m);
        for (int v : sa) {
            if (lms_map[v] != -1) sorted_lms.push_back(v);
        }
        std::vector<int> rec_s(m);
        int rec_upper = 0;
        rec_s[lms_map[sorted_lms[0]]] = 0;
        for (int i = 1; i < m; i++) {
            int l = sorted_lms[i - 1], r = sorted_lms[i];
            int end_l = (lms_map[l] + 1 < m) ? lms[lms_map[l] + 1] : n;
            int end_r = (lms_map[r] + 1 < m) ? lms[lms_map[r] + 1] : n;
            bool same = true;
            if (end_l - l != end_r - r) {
                same = false;
            } else {
                while (l < end_l) {
                    if (s[l] != s[r]) {
                        break;
                    }
                    l++;
                    r++;
                }
                if (l == n || s[l] != s[r]) same = false;
            }
            if (!same) rec_upper++;
            rec_s[lms_map[sorted_lms[i]]] = rec_upper;
        }

        auto rec_sa =
            sa_is<THRESHOLD_NAIVE, THRESHOLD_DOUBLING>(rec_s, rec_upper);

        for (int i = 0; i < m; i++) {
            sorted_lms[i] = lms[rec_sa[i]];
        }
        induce(sorted_lms);
    }
    return sa;
}

}  // namespace internal

std::vector<int> suffix_array(const std::vector<int>& s, int upper) {
    assert(0 <= upper);
    for (int d : s) {
        assert(0 <= d && d <= upper);
    }
    auto sa = internal::sa_is(s, upper);
    return sa;
}

template <class T> std::vector<int> suffix_array(const std::vector<T>& s) {
    int n = int(s.size());
    std::vector<int> idx(n);
    iota(idx.begin(), idx.end(), 0);
    sort(idx.begin(), idx.end(), [&](int l, int r) { return s[l] < s[r]; });
    std::vector<int> s2(n);
    int now = 0;
    for (int i = 0; i < n; i++) {
        if (i && s[idx[i - 1]] != s[idx[i]]) now++;
        s2[idx[i]] = now;
    }
    return internal::sa_is(s2, now);
}

std::vector<int> suffix_array(const std::string& s) {
    int n = int(s.size());
    std::vector<int> s2(n);
    for (int i = 0; i < n; i++) {
        s2[i] = s[i];
    }
    return internal::sa_is(s2, 255);
}

5) LCP array
// Reference:
// T. Kasai, G. Lee, H. Arimura, S. Arikawa, and K. Park,
// Linear-Time Longest-Common-Prefix Computation in Suffix Arrays and Its
// Applications
template <class T>
std::vector<int> lcp_array(const std::vector<T>& s,
                           const std::vector<int>& sa) {
    int n = int(s.size());
    assert(n >= 1);
    std::vector<int> rnk(n);
    for (int i = 0; i < n; i++) {
        rnk[sa[i]] = i;
    }
    std::vector<int> lcp(n - 1);
    int h = 0;
    for (int i = 0; i < n; i++) {
        if (h > 0) h--;
        if (rnk[i] == 0) continue;
        int j = sa[rnk[i] - 1];
        for (; j + h < n && i + h < n; h++) {
            if (s[j + h] != s[i + h]) break;
        }
        lcp[rnk[i] - 1] = h;
    }
    return lcp;
}

std::vector<int> lcp_array(const std::string& s, const std::vector<int>& sa) {
    int n = int(s.size());
    std::vector<int> s2(n);
    for (int i = 0; i < n; i++) {
        s2[i] = s[i];
    }
    return lcp_array(s2, sa);
}

6)Aho corasick
struct AhoCorasick {
    enum {alpha = 26, first = 'A'}; // change this!
    struct Node {
        // (nmatches is optional)
        int back, next[alpha], start = -1, end = -1, nmatches = 0;
        Node(int v) { memset(next, v, sizeof(next)); }
    };
    vector<Node> N;
    vi backp;
    void insert(string& s, int j) {
        assert(!s.empty());
        int n = 0;
        for (char c : s) {
            int& m = N[n].next[c - first];
            if (m == -1) { n = m = sz(N); N.emplace_back(-1); }
            else n = m;
        }
        if (N[n].end == -1) N[n].start = j;
        backp.push_back(N[n].end);
        N[n].end = j;
        N[n].nmatches++;
    }
    AhoCorasick(vector<string>& pat) : N(1, -1) {
        rep(i,0,sz(pat)) insert(pat[i], i);
        N[0].back = sz(N);
        N.emplace_back(0);

        queue<int> q;
        for (q.push(0); !q.empty(); q.pop()) {
            int n = q.front(), prev = N[n].back;
            rep(i,0,alpha) {
                int &ed = N[n].next[i], y = N[prev].next[i];
                if (ed == -1) ed = y;
                else {
                    N[ed].back = y;
                    (N[ed].end == -1 ? N[ed].end : backp[N[ed].start])
                        = N[y].end;
                    N[ed].nmatches += N[y].nmatches;
                    q.push(ed);
                }
            }
        }
    }
    vi find(string word) {
        int n = 0;
        vi res; // ll count = 0;
        for (char c : word) {
            n = N[n].next[c - first];
            res.push_back(N[n].end);
            // count += N[n].nmatches;
        }
        return res;
    }
    vector<vi> findAll(vector<string>& pat, string word) {
        vi r = find(word);
        vector<vi> res(sz(word));
        rep(i,0,sz(word)) {
            int ind = r[i];
            while (ind != -1) {
                res[i - sz(pat[ind]) + 1].push_back(ind);
                ind = backp[ind];
            }
        }
        return res;
    }
};

7)Manacher
// Manacher {{{
// Return <even_len, odd_len>
// - even_len[i] = length of longest palindrome centered at [i, i+1]
// - odd_len[i] = length of longest palindrome centered at i
//
std::array<vector<int>, 2> manacher(const string& s) {
    int n = s.size();
    std::array res = {vector<int> (n+1, 0), vector<int> (n, 0)};

    for (int z = 0; z < 2; z++) {
        for (int i = 0, l = 0, r = 0; i < n; i++) {
            int t = r - i + !z;
            if (i < r) res[z][i] = min(t, res[z][l + t]);

            int l2 = i - res[z][i], r2 = i + res[z][i] - !z;
            while (l2 && r2 + 1 < n && s[l2 - 1] == s[r2 + 1]) {
                ++res[z][i];
                --l2;
                ++r2;
            }
            if (r2 > r) {
                l = l2;
                r = r2;
            }
        }
        for (int i = 0; i < n; i++) {
            res[z][i] = 2*res[z][i] + z;
        }
    }
    res[0].erase(res[0].begin(), res[0].begin() + 1);
    res[0].pop_back();
    return res;
}
// }}}

8) Trie
const int lg = 31;

struct Trie {
    struct Node {
        Node *child[2];
        int exist, cnt;

        Node () {
            child[0] = child[1] = NULL;
            exist = cnt = 0;
        }
    };
    
    int cur;
    Node *root;
    Trie() : cur(0) {
        root = new Node();
    };

    void add(int val) {
        Node* p = root;
        FORD(i, lg - 1, 0) {
            int c = ((val >> i) & 1);
            if (p->child[c] == NULL) p->child[c] = new Node();
            p = p->child[c];
            p->cnt++;
        }
        p->exist++;
    }

    bool find(int val) {
        Node* p = root;
        FORD(i, lg - 1, 0) {
            int c = ((val >> i) & 1);
            if (p->child[c] == NULL) return false;
            p = p->child[c];
        }
        return (p->exist != 0);
    }

    bool delete_dfs(Node *p, int val, int idx) {
        if (idx >= 0) {
            int c = ((val >> idx) & 1);
            bool is_del = delete_dfs(p->child[c], val, idx - 1);
            if (is_del) p->child[c] = NULL;
        }
        else p->exist--;

        if (p != root) {
            p->cnt--;
            if (p->cnt == 0) {
                delete(p);
                return true;
            }
        }
        return false;
    }

    void del(int val) {
        if (!find(val)) return;
        delete_dfs(root, val, lg - 1);
    }

    int get(int x) {
        int  res = 0;
        Node* p = root;
        FORD (i, lg - 1, 0) {
            int c = (x >> i) & 1;
            if (p->child[c ^ 1] != NULL) {
                res += (1ll << i);
                p = p->child[c ^ 1];
            }
            else {
                p = p->child[c];
            }
        }
        return res;
    }
};

9) Lyndon Factor
vector<string> duval(string s) {
    int N = sz(s); vector<string> factors;
    for (int i = 0; i < N; ) {
        int j = i+1, k = i;
        for (; j < N && s[k] <= s[j]; ++j) {
            if (s[k] < s[j]) k = i;
            else ++k;
        }
        for (; i <= k; i += j-k) factors.pb(s.substr(i,j-k));
    }
    return factors;
}
int minRotation(string s) { 
    int N = sz(s); s += s;
    vector<string> d = duval(s); int ind = 0, ans = 0;
    while (ans+sz(d[ind]) < N) ans += sz(d[ind++]);
    while (ind && d[ind] == d[ind-1]) ans -= sz(d[ind--]);
    return ans;
}

10)Suffix Automaton
struct Node {
    int len, link; // len = max length of suffix in this class
    int next[33];
};
Node s[MN * 2];
set< pair<int,int> > order; // in most application we'll need to sort by len
struct Automaton {
    int sz, last;
    Automaton() {
        order.clear();
        sz = last = 0;
        s[0].len = 0;
        s[0].link = -1;
        ++sz;
        // need to reset next if necessary
    }
    void extend(char c) {
        c = c - 'A';
        int cur = sz++, p;
        s[cur].len = s[last].len + 1;
        order.insert(make_pair(s[cur].len, cur));

        for(p = last; p != -1 && !s[p].next[c]; p = s[p].link)
            s[p].next[c] = cur;
        if (p == -1) s[cur].link = 0;
        else {
            int q = s[p].next[c];
            if (s[p].len + 1 == s[q].len) s[cur].link = q;
            else {
                int clone = sz++;
                s[clone].len = s[p].len + 1;
                memcpy(s[clone].next, s[q].next, sizeof(s[q].next));
                s[clone].link = s[q].link;
                order.insert(make_pair(s[clone].len, clone));

                for(; p != -1 && s[p].next[c] == q; p = s[p].link)
                    s[p].next[c] = clone;
                s[q].link = s[cur].link = clone;
            }
        }
        last = cur;
    }
};
// Construct:
// Automaton sa; for(char c : s) sa.extend(c);
// 1. Number of distinct substr:
//    - Find number of different paths --> DFS on SA
//    - f[u] = 1 + sum( f[v] for v in s[u].next
// 2. Number of occurrences of a substr:
//    - Initially, in extend: s[cur].cnt = 1; s[clone].cnt = 0;
//    - for(it : reverse order)
//        p = nodes[it->second].link;
//        nodes[p].cnt += nodes[it->second].cnt
// 3. Find total length of different substrings:
//    - We have f[u] = number of strings starting from node u
//    - ans[u] = sum(ans[v] + d[v] for v in next[u])
// 4. Lexicographically k-th substring
//    - Based on number of different substring
// 5. Smallest cyclic shift
//    - Build SA of S+S, then just follow smallest link
// 6. Find first occurrence
//    - firstpos[cur] = len[cur] - 1, firstpos[clone] = firstpos[q]

11)Suffix Tree
struct SuffixTree {
    enum { N = 200010, ALPHA = 26 }; // N ~ 2*maxlen+10
    int toi(char c) { return c - 'a'; }
    string a; // v = cur node, q = cur position
    int t[N][ALPHA],l[N],r[N],p[N],s[N],v=0,q=0,m=2;

    void ukkadd(int i, int c) { suff:
        if (r[v]<=q) {
            if (t[v][c]==-1) { t[v][c]=m;  l[m]=i;
                p[m++]=v; v=s[v]; q=r[v];  goto suff; }
            v=t[v][c]; q=l[v];
        }
        if (q==-1 || c==toi(a[q])) q++; else {
            l[m+1]=i;  p[m+1]=m;  l[m]=l[v];  r[m]=q;
            p[m]=p[v];  t[m][c]=m+1;  t[m][toi(a[q])]=v;
            l[v]=q;  p[v]=m;  t[p[m]][toi(a[l[m]])]=m;
            v=s[p[m]];  q=l[m];
            while (q<r[m]) { v=t[v][toi(a[q])];  q+=r[v]-l[v]; }
            if (q==r[m])  s[m]=v;  else s[m]=m+2;
            q=r[v]-(q-r[m]);  m+=2;  goto suff;
        }
    }

    SuffixTree(string a) : a(a) {
        fill(r,r+N,sz(a));
        memset(s, 0, sizeof s);
        memset(t, -1, sizeof t);
        fill(t[1],t[1]+ALPHA,0);
        s[0] = 1; l[0] = l[1] = -1; r[0] = r[1] = p[0] = p[1] = 0;
        rep(i,0,sz(a)) ukkadd(i, toi(a[i]));
    }

    // example: find longest common substring (uses ALPHA = 28)
    pii best;
    int lcs(int node, int i1, int i2, int olen) {
        if (l[node] <= i1 && i1 < r[node]) return 1;
        if (l[node] <= i2 && i2 < r[node]) return 2;
        int mask = 0, len = node ? olen + (r[node] - l[node]) : 0;
        rep(c,0,ALPHA) if (t[node][c] != -1)
            mask |= lcs(t[node][c], i1, i2, len);
        if (mask == 3)
            best = max(best, {len, r[node] - len});
        return mask;
    }
    static pii LCS(string s, string t) {
        SuffixTree st(s + (char)('z' + 1) + t + (char)('z' + 2));
        st.lcs(0, sz(s), sz(s) + 1 + sz(t), 0);
        return st.best;
    }
};

12)Rabin karp
//String matching
vector<int> rabin_karp(string const& s, string const& t) {
    const int p = 31; 
    const int m = 1e9 + 9;
    int S = s.size(), T = t.size();

    vector<long long> p_pow(max(S, T)); 
    p_pow[0] = 1; 
    for (int i = 1; i < (int)p_pow.size(); i++) 
        p_pow[i] = (p_pow[i-1] * p) % m;

    vector<long long> h(T + 1, 0); 
    for (int i = 0; i < T; i++)
        h[i+1] = (h[i] + (t[i] - 'a' + 1) * p_pow[i]) % m; 
    long long h_s = 0; 
    for (int i = 0; i < S; i++) 
        h_s = (h_s + (s[i] - 'a' + 1) * p_pow[i]) % m; 

    vector<int> occurrences;
    for (int i = 0; i + S - 1 < T; i++) {
        long long cur_h = (h[i+S] + m - h[i]) % m;
        if (cur_h == h_s * p_pow[i] % m)
            occurrences.push_back(i);
    }
    return occurrences;
}

NUMBER THEORY

1)Namsee add and mul
ll add(ll a, ll b) {
    a += mod, b += mod;
    a %= mod, b %= mod;
    return (a + b + mod) % mod;
}
 
ll mul(ll a, ll b) {
    a += mod, b += mod;
    a %= mod, b %= mod;
    return ((a * b) + mod) % mod;
}

2)mod inverse
#line 2 "Mod/mod_inv.hpp"

#include <cassert>
#include <type_traits>

// gcd(a, m) != 1 return -1 
template <typename T>
T inv_mod(T a, T m) {
  if (m == 1) return 0;
  if (a >= m) a %= m;
  if (a < 0) a += m;
  if(__gcd(a,m)!=1) return -1;
  T b = m, s = 1, t = 0;
  while (true) {
    if (a == 1) return s;
    t -= b / a * s;
    b %= a;
    if (b == 1) return t + m;
    s -= a / b * t;
    a %= b;
  }
}

3)Mod mull
typedef unsigned long long ull;
ull modmul(ull a, ull b, ull M) {
    ll ret = a * b - M * ull(1.L / M * a * b);
    return ret + M * (ret < 0) - M * (ret >= (ll)M);
}
ull modpow(ull b, ull e, ull mod) {
    ull ans = 1;
    for (; e; b = modmul(b, b, mod), e /= 2)
        if (e & 1) ans = modmul(ans, b, mod);
    return ans;
}

4)Mod pow
const ll mod = 1000000007; // faster if const

ll modpow(ll b, ll e) {
    ll ans = 1;
    for (; e; b = b * b % mod, e /= 2)
        if (e & 1) ans = ans * b % mod;
    return ans;
}




5)Mod_sqrt
/*
  find X so that X^2=Y(mod p) 
*/
#include "ModPow.h"
ll mod_sqrt(ll a, ll p) {
    a %= p; if (a < 0) a += p;
    if (a == 0) return 0;
    assert(modpow(a, (p-1)/2, p) == 1); // else no solution
    if (p % 4 == 3) return modpow(a, (p+1)/4, p);
    // a^(n+3)/8 or 2^(n+3)/8 * 2^(n-1)/4 works if p % 8 == 5
    ll s = p - 1, n = 2;
    int r = 0, m;
    while (s % 2 == 0)
        ++r, s /= 2;
    /// find a non-square mod p
    while (modpow(n, (p - 1) / 2, p) != p - 1) ++n;
    ll x = modpow(a, (s + 1) / 2, p);
    ll b = modpow(a, s, p), g = modpow(n, s, p);
    for (;; r = m) {
        ll t = b;
        for (m = 0; m < r && t != 1; ++m)
            t = t * t % p;
        if (m == 0) return x;
        ll gs = modpow(g, 1LL << (r - m - 1), p);
        g = gs * gs % p;
        x = x * gs % p;
        b = b * g % p;
    }
}

6)Mod sum
typedef unsigned long long ull;
//(sum from i=0 to n-1)i=n(n-1)/2
ull sumsq(ull to) { return to / 2 * ((to-1) | 1); }
/// ^ written in a weird way to deal with overflows correctly

//(sum from i=0 to n-1)[(c+k*i)/m]
ull divsum(ull to, ull c, ull k, ull m) {
    ull res = k / m * sumsq(to) + c / m * to;
    k %= m; c %= m;
    if (!k) return res;
    ull to2 = (to * k + c) / m;
    return res + (to - 1) * to2 - divsum(to2, m-1 - c, m, k);
}
//(sum from i=0 to n-1)(c+k*i) mod m
ll modsum(ull to, ll c, ll k, ll m) {
    c = ((c % m) + m) % m;
    k = ((k % m) + m) % m;
    return to * c + k * sumsq(to) - m * divsum(to, c, k, m);
}

7)discrete logarithm
//a^x=b(mod m)
ll modLog(ll a, ll b, ll m) {
    ll n = (ll) sqrt(m) + 1, e = 1, f = 1, j = 1;
    unordered_map<ll, ll> A;
    while (j <= n && (e = f = e * a % m) != b % m)
        A[e * b % m] = j++;
    if (e == b % m) return j;
    if (__gcd(m, e) == __gcd(m, b)) 
        rep(i,2,n+2) if (A.count(e = e * f % m))
            return n * i - A[e];
    return -1;
}

8)Primitive root
int powmod (int a, int b, int p) {
    int res = 1;
    while (b)
        if (b & 1)
            res = int (res * 1ll * a % p),  --b;
        else
            a = int (a * 1ll * a % p),  b >>= 1;
    return res;
}

int primitive_root (int p) {
    vector<int> fact;
    int phi = p-1,  n = phi;
    for (int i=2; i*i<=n; ++i)
        if (n % i == 0) {
            fact.push_back (i);
            while (n % i == 0)
                n /= i;
        }
    if (n > 1)
        fact.push_back (n);

    for (int res=2; res<=p; ++res) {
        bool ok = true;
        for (size_t i=0; i<fact.size() && ok; ++i)
            ok &= powmod (res, phi / fact[i], p) != 1;
        if (ok)  return res;
    }
    return -1;
}

9)Extended Euclid
//ax+by=gcd(a,b)
ll euclid(ll a, ll b, ll &x, ll &y) {
    if (!b) return x = 1, y = 0, a;
    ll d = euclid(b, a % b, y, x);
    return y -= a/b * x, d;
}

10)Fast GCD
long long gcdll(long long a, long long b) {
    if (!a) return b;
    if (!b) return a;
    int az = __builtin_ctzll(a);
    int bz = __builtin_ctzll(b);
    int shift = min(az, bz);
    b >>= bz;
    while (a) {
        a >>= az;
        long long diff = b - a;
        az = __builtin_ctzll(diff);
        b = min(a, b); a = abs(diff);
    }
    return b << shift;
}

11)CRT
#include "euclid.h"

ll crt(ll a, ll m, ll b, ll n) {
    if (n > m) swap(a, b), swap(m, n);
    ll x, y, g = euclid(m, n, x, y);
    assert((a - b) % g == 0); // else no solution
    x = (b - a) % n * x % n / g * m + a;
    return x < 0 ? x + m*n/g : x;
}

12)Factorize
#include "ModMulLL.h"
#include "MillerRabin.h"

ull pollard(ull n) {
    ull x = 0, y = 0, t = 30, prd = 2, i = 1, q;
    auto f = [&](ull x) { return modmul(x, x, n) + i; };
    while (t++ % 40 || __gcd(prd, n) == 1) {
        if (x == y) x = ++i, y = f(x);
        if ((q = modmul(prd, max(x,y) - min(x,y), n))) prd = q;
        x = f(x), y = f(f(y));
    }
    return __gcd(prd, n);
}
vector<ull> factor(ull n) {
    if (n == 1) return {};
    if (isPrime(n)) return {n};
    ull x = pollard(n);
    auto l = factor(x), r = factor(n / x);
    l.insert(l.end(), all(r));
    return l;
}

13)Prime test
/**
 * Author: chilli, c1729, Simon Lindholm
 * Date: 2019-03-28
 * License: CC0
 * Source: Wikipedia, https://miller-rabin.appspot.com/
 * Description: Deterministic Miller-Rabin primality test.
 * Guaranteed to work for numbers up to $7 \cdot 10^{18}$; for larger numbers, use Python and extend A randomly.
 * Time: 7 times the complexity of $a^b \mod c$.
 * Status: Stress-tested
 */
#pragma once

#include "ModMulLL.h"

bool isPrime(ull n) {
    if (n < 2 || n % 6 % 4 != 1) return (n | 1) == 3;
    ull A[] = {2, 325, 9375, 28178, 450775, 9780504, 1795265022},
        s = __builtin_ctzll(n-1), d = n >> s;
    for (ull a : A) {   // ^ count trailing zeroes
        ull p = modpow(a%n, d, n), i = s;
        while (p != 1 && p != n - 1 && a % n && i--)
            p = modmul(p, p, n);
        if (p != n-1 && i != s) return 0;
    }
    return 1;
}

14)Sieve
const int maxn = 1000000 + 5; //10^6 + 5
bool is_prime[maxn];
void Eratosthenes(int n){
    for (int i = 2; i <= n; i++)
        is_prime[i] = true;
    for (int i = 2; i * i <= n; i++) {
        if (is_prime[i]) {
            // j sẽ bắt đầu chạy từ i * i
            for (int j = i * i; j <= n; j += i)
                is_prime[j] = false;
        }
    }
}

15)Euler phi
/*
   phi(n)=n(mul from i=1 to k)(1-1/pi)
*/
template <typename T>
T euler_phi(T n) {
  T ret = n;
  for (T i = 2; i * i <= n; i++) {
    if (n % i == 0) {
      ret -= ret / i;
      while (n % i == 0) n /= i;
    }
  }
  if (n > 1) ret -= ret / n;
  return ret;
}


16)Other template
template<typename T>
T mod(T a, T b)
{
    return ((a%b)+b)%b;
}

template<typename T>
T lcm(T a, T b)
{
    return a/gcd(a, b)*b;
}

template<typename T>
T binpow(T a, T b, T m)
{
    T ret = 1;
    while (b)
    {
        if (b & 1)
            ret = mod(ret*a, m);
        a = mod(a*a, m);
        b >>= 1;
    }
    return ret;
}

template<typename T>
void euler_totient(T n)
{
    for (T i=1; i<=n; i++) phi[i] = i;
    for (T i=2; i<=n; i++)
    {
        if (phi[i] == i)
            for (T j=i; j<=n; j+=i) phi[j] -= phi[j]/i;
    }
}

template<typename T>
void precalc_mobius()
{
    mobius[1] = 1;
    for (T i=2; i<LimN; i++)
    {
        mobius[i]--;
        for (T j=i+1; j<LimN; j+=i) mobius[j] -= mobius[i];
    }
}

17)Combinatoric
#pragma once

#include<vector>
#include<assert.h>

namespace po167{
template<class T>
struct Binomial{
    std::vector<T> fact_vec, fact_inv_vec;
    void extend(int m = -1){
        int n = fact_vec.size();
        if (m == -1) m = n * 2;
        if (n >= m) return;
        fact_vec.resize(m);
        fact_inv_vec.resize(m);
        for (int i = n; i < m; i++){
            fact_vec[i] = fact_vec[i - 1] * T(i);
        }
        fact_inv_vec[m - 1] = T(1) / fact_vec[m - 1];
        for (int i = m - 1; i > n; i--){
            fact_inv_vec[i - 1] = fact_inv_vec[i] * T(i);
        }
    }
    Binomial(int MAX = 0){
        fact_vec.resize(1, T(1));
        fact_inv_vec.resize(1, T(1));
        extend(MAX + 1);
    }

    T fact(int i){
        if (i < 0) return 0;
        while (int(fact_vec.size()) <= i) extend();
        return fact_vec[i];
    }
    T invfact(int i){
        if (i < 0) return 0;
        while (int(fact_inv_vec.size()) <= i) extend();
        return fact_inv_vec[i];
    }
    T C(int a, int b){
        if (a < b || b < 0) return 0;
        return fact(a) * invfact(b) * invfact(a - b);
    }
    T invC(int a, int b){
        if (a < b || b < 0) return 0;
        return fact(b) * fact(a - b) *invfact(a);
    }
    T P(int a, int b){
        if (a < b || b < 0) return 0;
        return fact(a) * invfact(a - b);
    }
    T inv(int a){
        if (a < 0) return inv(-a) * T(-1);
        if (a == 0) return 1;
        return fact(a - 1) * invfact(a);
    }
    T Catalan(int n){
        if (n < 0) return 0;
        return fact(2 * n) * invfact(n + 1) * invfact(n);
    }
    T narayana(int n, int k){
        if (n <= 0 || n < k || k < 1) return 0;
        return C(n, k) *  C(n, k - 1) * inv(n);
    }
    T Catalan_pow(int n,int d){
        if (n < 0 || d < 0) return 0;
        if (d == 0){
            if (n == 0) return 1;
            return 0;
        }
        return T(d) * inv(d + n) * C(2 * n + d - 1, n);
    }
    // retrun [x^a] 1/(1-x)^b
    T ruiseki(int a,int b){
        if (a < 0 || b < 0) return 0;
        if (a == 0){
            return 1;
        }
        return C(a + b - 1, b - 1);
    }
    // (a, b) -> (c, d)
    // always x + e >= y
    T mirror(int a, int b, int c, int d, int e = 0){
        if (a + e < b || c + e < d) return 0;
        if (a > c || b > d) return 0;
        a += e;
        c += e;
        return C(c + d - a - b, c - a) - C(c + d - a - b, c - b + 1); 
    }
    // return sum_{i = 0, ... , a} sum_{j = 0, ... , b} C(i + j, i)
    // return C(a + b + 2, a + 1) - 1;
    T gird_sum(int a, int b){
        if (a < 0 || b < 0) return 0;
        return C(a + b + 2, a + 1) - 1;
    }
    // return sum_{i = a, ..., b - 1} sum_{j = c, ... , d - 1} C(i + j, i)
    // AGC 018 E
    T gird_sum_2(int a, int b, int c, int d){
        if (a >= b || c >= d) return 0;
        a--, b--, c--, d--;
        return gird_sum(a, c) - gird_sum(a, d) - gird_sum(b, c) + gird_sum(b, d);
    }
};
}

18)FFT
// Note:
// - When convert double -> int, use my_round(x) which handles negative numbers
//   correctly.
// FFT {{{
// Source: https://github.com/kth-competitive-programming/kactl/blob/main/content/numerical/FastFourierTransform.h

using ld = double;
// Can use std::complex<ld> instead to make code shorter (but it will be slightly slower)
struct Complex {
    ld x[2];

    Complex() { x[0] = x[1] = 0.0; }
    Complex(ld a) { x[0] = a; }
    Complex(ld a, ld b) { x[0] = a; x[1] = b; }
    Complex(const std::complex<ld>& c) {
        x[0] = c.real();
        x[1] = c.imag();
    }

    Complex conj() const {
        return Complex(x[0], -x[1]);
    }

    Complex operator + (const Complex& c) const {
        return Complex {
            x[0] + c.x[0],
            x[1] + c.x[1],
        };
    }
    Complex operator - (const Complex& c) const {
        return Complex {
            x[0] - c.x[0],
            x[1] - c.x[1],
        };
    }
    Complex operator * (const Complex& c) const {
        return Complex(
            x[0] * c.x[0] - x[1] * c.x[1],
            x[0] * c.x[1] + x[1] * c.x[0]
        );
    }

    Complex& operator += (const Complex& c) { return *this = *this + c; }
    Complex& operator -= (const Complex& c) { return *this = *this - c; }
    Complex& operator *= (const Complex& c) { return *this = *this * c; }
};
void fft(vector<Complex>& a) {
    int n = a.size();
    int L = 31 - __builtin_clz(n);
    static vector<Complex> R(2, 1);
    static vector<Complex> rt(2, 1);
    for (static int k = 2; k < n; k *= 2) {
        R.resize(n);
        rt.resize(n);
        auto x = Complex(polar(ld(1.0), acos(ld(-1.0)) / k));
        for (int i = k; i < 2*k; ++i) {
            rt[i] = R[i] = i&1 ? R[i/2] * x : R[i/2];
        }
    }
    vector<int> rev(n);
    for (int i = 0; i < n; ++i) rev[i] = (rev[i/2] | (i&1) << L) / 2;
    for (int i = 0; i < n; ++i) if (i < rev[i]) swap(a[i], a[rev[i]]);

    for (int k = 1; k < n; k *= 2) {
        for (int i = 0; i < n; i += 2*k) {
            for (int j = 0; j < k; ++j) {
                auto x = (ld*) &rt[j+k].x, y = (ld*) &a[i+j+k].x;
                Complex z(x[0]*y[0] - x[1]*y[1], x[0]*y[1] + x[1]*y[0]);
                a[i + j + k] = a[i + j] - z;
                a[i + j] += z;
            }
        }
    }
}
vector<ld> multiply(const vector<ld>& a, const vector<ld>& b) {
    if (a.empty() || b.empty()) return {};
    vector<ld> res(a.size() + b.size() - 1);
    int L = 32 - __builtin_clz(res.size()), n = 1<<L;
    vector<Complex> in(n), out(n);

    for (size_t i = 0; i < a.size(); ++i) in[i].x[0] = a[i];
    for (size_t i = 0; i < b.size(); ++i) in[i].x[1] = b[i];

    fft(in);
    for (Complex& x : in) x *= x;

    for (int i = 0; i < n; ++i) out[i] = in[-i & (n-1)] - in[i].conj();
    fft(out);

    for (size_t i = 0; i < res.size(); ++i) res[i] = out[i].x[1] / (4*n);
    return res;
}
long long my_round(ld x) {
    if (x < 0) return -my_round(-x);
    return (long long) (x + 1e-2);
}
vector<long long> multiply(const vector<int>& a, const vector<int>& b) {
    vector<ld> ad(a.begin(), a.end());
    vector<ld> bd(b.begin(), b.end());
    auto rd = multiply(ad, bd);
    vector<long long> res(rd.size());
    for (int i = 0; i < (int) res.size(); ++i) {
        res[i] = my_round(rd[i]);
    }
    return res;
}
// }}}

19)NTT
// NTT {{{
// Faster than NTT_chemthan.h
// Usage:
// auto c = multiply(a, b);
// where a and b are vector<ModInt<ANY_MOD>>
// (If mod is NOT NTT_PRIMES, it does 3 NTT and combine result)
constexpr int NTT_PRIMES[] = {998244353, 167772161, 469762049};
// assumptions:
// - |a| is power of 2
// - mint::mod() is a valid NTT primes (2^k * m + 1)
template<typename mint> void ntt(std::vector<mint>& a, bool is_inverse) {
    int n = a.size();
    if (n == 1) return;

    static const int mod = mint::mod();
    static const mint root = mint::get_primitive_root();
    assert(__builtin_popcount(n) == 1 && (mod - 1) % n == 0);

    static std::vector<mint> w{1}, iw{1};
    for (int m = w.size(); m < n / 2; m *= 2) {
        mint dw = root.pow((mod - 1) / (4 * m));
        mint dwinv = dw.inv();
        w.resize(m * 2);
        iw.resize(m * 2);
        for (int i = 0; i < m; ++i) {
            w[m + i] = w[i] * dw;
            iw[m + i] = iw[i] * dwinv;
        }
    }

    if (!is_inverse) {
        for (int m = n; m >>= 1; ) {
            for (int s = 0, k = 0; s < n; s += 2 * m, ++k) {
                for (int i = s; i < s + m; ++i) {
                    mint x = a[i], y = a[i + m] * w[k];
                    a[i] = x + y;
                    a[i + m] = x - y;
                }
            }
        }
    } else {
        for (int m = 1; m < n; m *= 2) {
            for (int s = 0, k = 0; s < n; s += 2 * m, ++k) {
                for (int i = s; i < s + m; ++i) {
                    mint x = a[i], y = a[i + m];
                    a[i] = x + y;
                    a[i + m] = (x - y) * iw[k];
                }
            }
        }
        int n_inv = mint(n).inv().x;
        for (auto& v : a) v *= n_inv;
    }
}

template<typename mint>
std::vector<mint> ntt_multiply(int sz, std::vector<mint> a, std::vector<mint> b) {
    a.resize(sz);
    b.resize(sz);
    if (a == b) { // optimization for squaring polynomial
        ntt(a, false);
        b = a;
    } else {
        ntt(a, false);
        ntt(b, false);
    }
    for (int i = 0; i < sz; ++i) a[i] *= b[i];
    ntt(a, true);
    return a;
}

template<int MOD, typename mint>
std::vector<ModInt<MOD>> convert_mint_and_multiply(
        int sz,
        const std::vector<mint>& a,
        const std::vector<mint>& b) {
    using mint2 = ModInt<MOD>;

    std::vector<mint2> a2(a.size()), b2(b.size());
    for (size_t i = 0; i < a.size(); ++i) {
        a2[i] = mint2(a[i].x);
    }
    for (size_t i = 0; i < b.size(); ++i) {
        b2[i] = mint2(b[i].x);
    }
    return ntt_multiply(sz, a2, b2);
}

long long combine(int r0, int r1, int r2, int mod) {
    using mint2 = ModInt<NTT_PRIMES[2]>;
    static const long long m01 = 1LL * NTT_PRIMES[0] * NTT_PRIMES[1];
    static const long long m0_inv_m1 = ModInt<NTT_PRIMES[1]>(NTT_PRIMES[0]).inv().x;
    static const long long m01_inv_m2 = mint2(m01).inv().x;

    int v1 = (m0_inv_m1 * (r1 + NTT_PRIMES[1] - r0)) % NTT_PRIMES[1];
    auto v2 = (mint2(r2) - r0 - mint2(NTT_PRIMES[0]) * v1) * m01_inv_m2;
    return (r0 + 1LL * NTT_PRIMES[0] * v1 + m01 % mod * v2.x) % mod;
}

template<typename mint>
std::vector<mint> multiply(const std::vector<mint>& a, const std::vector<mint>& b) {
    if (a.empty() || b.empty()) return {};
    int sz = 1, sz_a = a.size(), sz_b = b.size();
    while (sz < sz_a + sz_b) sz <<= 1;
    if (sz <= 16) {
        std::vector<mint> res(sz_a + sz_b - 1);
        for (int i = 0; i < sz_a; ++i) {
            for (int j = 0; j < sz_b; ++j) {
                res[i + j] += a[i] * b[j];
            }
        }
        return res;
    }

    int mod = mint::mod();
    std::vector<mint> res;
    if (std::find(std::begin(NTT_PRIMES), std::end(NTT_PRIMES), mod) != std::end(NTT_PRIMES)) {
        res = ntt_multiply(sz, a, b);
    } else {
        auto c0 = convert_mint_and_multiply<NTT_PRIMES[0], mint> (sz, a, b);
        auto c1 = convert_mint_and_multiply<NTT_PRIMES[1], mint> (sz, a, b);
        auto c2 = convert_mint_and_multiply<NTT_PRIMES[2], mint> (sz, a, b);

        res.resize(sz);
        for (int i = 0; i < sz; ++i) {
            res[i] = combine(c0[i].x, c1[i].x, c2[i].x, mod);
        }
    }

    res.resize(sz_a + sz_b - 1);
    return res;
}
// }}}

20)Matrix
#pragma once

#include "inverse-matrix.hpp"

template <class T>
struct Matrix {
  vector<vector<T> > A;

  Matrix() = default;
  Matrix(int n, int m) : A(n, vector<T>(m, T())) {}
  Matrix(int n) : A(n, vector<T>(n, T())){};

  int H() const { return A.size(); }

  int W() const { return A[0].size(); }

  int size() const { return A.size(); }

  inline const vector<T> &operator[](int k) const { return A[k]; }

  inline vector<T> &operator[](int k) { return A[k]; }

  static Matrix I(int n) {
    Matrix mat(n);
    for (int i = 0; i < n; i++) mat[i][i] = 1;
    return (mat);
  }

  Matrix &operator+=(const Matrix &B) {
    int n = H(), m = W();
    assert(n == B.H() && m == B.W());
    for (int i = 0; i < n; i++)
      for (int j = 0; j < m; j++) (*this)[i][j] += B[i][j];
    return (*this);
  }

  Matrix &operator-=(const Matrix &B) {
    int n = H(), m = W();
    assert(n == B.H() && m == B.W());
    for (int i = 0; i < n; i++)
      for (int j = 0; j < m; j++) (*this)[i][j] -= B[i][j];
    return (*this);
  }

  Matrix &operator*=(const Matrix &B) {
    int n = H(), m = B.W(), p = W();
    assert(p == B.H());
    vector<vector<T> > C(n, vector<T>(m, T{}));
    for (int i = 0; i < n; i++)
      for (int k = 0; k < p; k++)
        for (int j = 0; j < m; j++) C[i][j] += (*this)[i][k] * B[k][j];
    A.swap(C);
    return (*this);
  }

  Matrix &operator^=(long long k) {
    Matrix B = Matrix::I(H());
    while (k > 0) {
      if (k & 1) B *= *this;
      *this *= *this;
      k >>= 1LL;
    }
    A.swap(B.A);
    return (*this);
  }

  Matrix operator+(const Matrix &B) const { return (Matrix(*this) += B); }

  Matrix operator-(const Matrix &B) const { return (Matrix(*this) -= B); }

  Matrix operator*(const Matrix &B) const { return (Matrix(*this) *= B); }

  Matrix operator^(const long long k) const { return (Matrix(*this) ^= k); }

  bool operator==(const Matrix &B) const {
    assert(H() == B.H() && W() == B.W());
    for (int i = 0; i < H(); i++)
      for (int j = 0; j < W(); j++)
        if (A[i][j] != B[i][j]) return false;
    return true;
  }

  bool operator!=(const Matrix &B) const {
    assert(H() == B.H() && W() == B.W());
    for (int i = 0; i < H(); i++)
      for (int j = 0; j < W(); j++)
        if (A[i][j] != B[i][j]) return true;
    return false;
  }

  Matrix inverse() const {
    assert(H() == W());
    Matrix B(H());
    B.A = inverse_matrix(A);
    return B;
  }

  friend ostream &operator<<(ostream &os, const Matrix &p) {
    int n = p.H(), m = p.W();
    for (int i = 0; i < n; i++) {
      os << (i ? "   " : "") << "[";
      for (int j = 0; j < m; j++) {
        os << p[i][j] << (j + 1 == m ? "]\n" : ",");
      }
    }
    return (os);
  }

  T determinant() const {
    Matrix B(*this);
    assert(H() == W());
    T ret = 1;
    for (int i = 0; i < H(); i++) {
      int idx = -1;
      for (int j = i; j < W(); j++) {
        if (B[j][i] != 0) {
          idx = j;
          break;
        }
      }
      if (idx == -1) return 0;
      if (i != idx) {
        ret *= T(-1);
        swap(B[i], B[idx]);
      }
      ret *= B[i][i];
      T inv = T(1) / B[i][i];
      for (int j = 0; j < W(); j++) {
        B[i][j] *= inv;
      }
      for (int j = i + 1; j < H(); j++) {
        T a = B[j][i];
        if (a == 0) continue;
        for (int k = i; k < W(); k++) {
          B[j][k] -= B[i][k] * a;
        }
      }
    }
    return ret;
  }
};

/**
 * @brief 行列ライブラリ
 */

21) inverse matrix
#pragma once
x
#include "gauss-elimination.hpp"

template <typename mint>
vector<vector<mint>> inverse_matrix(const vector<vector<mint>>& a) {
  int N = a.size();
  assert(N > 0);
  assert(N == (int)a[0].size());

  vector<vector<mint>> m(N, vector<mint>(2 * N));
  for (int i = 0; i < N; i++) {
    copy(begin(a[i]), end(a[i]), begin(m[i]));
    m[i][N + i] = 1;
  }

  auto [rank, det] = GaussElimination(m, N, true);
  if (rank != N) return {};

  vector<vector<mint>> b(N);
  for (int i = 0; i < N; i++) {
    copy(begin(m[i]) + N, end(m[i]), back_inserter(b[i]));
  }
  return b;
}

22)Gaussian
#line 2 "matrix/gauss-elimination.hpp"

#include <utility>
#include <vector>
using namespace std;

template <typename T>
std::pair<int, T> GaussElimination(vector<vector<T>> &a, int pivot_end = -1,
                                   bool diagonalize = false) {
  if (a.empty()) return {0, 1};
  int H = a.size(), W = a[0].size(), rank = 0;
  if (pivot_end == -1) pivot_end = W;
  T det = 1;
  for (int j = 0; j < pivot_end; j++) {
    int idx = -1;
    for (int i = rank; i < H; i++) {
      if (a[i][j] != T(0)) {
        idx = i;
        break;
      }
    }
    if (idx == -1) {
      det = 0;
      continue;
    }
    if (rank != idx) det = -det, swap(a[rank], a[idx]);
    det *= a[rank][j];
    if (diagonalize && a[rank][j] != T(1)) {
      T coeff = T(1) / a[rank][j];
      for (int k = j; k < W; k++) a[rank][k] *= coeff;
    }
    int is = diagonalize ? 0 : rank + 1;
    for (int i = is; i < H; i++) {
      if (i == rank) continue;
      if (a[i][j] != T(0)) {
        T coeff = a[i][j] / a[rank][j];
        for (int k = j; k < W; k++) a[i][k] -= a[rank][k] * coeff;
      }
    }
    rank++;
  }
  return make_pair(rank, det);
}

23)Mat mul
/*
   @author: Kiffaz
   Des: Matrix product
*/
template <class T>
std::vector<std::vector<T>> matmul(const std::vector<std::vector<T>>& A, 
                                            const std::vector<std::vector<T>>& B) {

    size_t m = A.size();
    size_t p = A[0].size();
    size_t n = B[0].size();

    std::vector<std::vector<T>> B_T(n, std::vector<T>(p));
    for (size_t i = 0; i < p; ++i)
        for (size_t j = 0; j < n; ++j)
            B_T[j][i] = B[i][j];

    std::vector<std::vector<T>> res(m, std::vector<T>(n, T()));

    #pragma omp parallel for
    for (size_t i = 0; i < m; ++i) {
        for (size_t j = 0; j < n; ++j) {
            T sum = 0;
            for (size_t k = 0; k < p; ++k) {
                sum += A[i][k] * B_T[j][k];
            }
            res[i][j] = sum;
        }
    }

    return res;
}
//if size very big do not use this 
template <class T, int N>
std::array<std::array<T, N>, N> matmul(const std::array<std::array<T, N>, N>& A, 
                                      const std::array<std::array<T, N>, N>& B) {
    std::array<std::array<T, N>, N> res = {};
    for (int i = 0; i < N; ++i) {
        for (int k = 0; k < N; ++k) {
            for (int j = 0; j < N; ++j) {
                res[i][j] += A[i][k] * B[k][j];
            }
        }
    }
    return res;
}

24)Mat pow
#ifdef _OPENMP
#include <omp.h>
#endif

template<typename T>
std::vector<std::vector<T>> multiply(const std::vector<std::vector<T>>& A, 
                                     const std::vector<std::vector<T>>& B) {
    size_t m = A.size();
    size_t p = A[0].size();
    size_t n = B[0].size();

    std::vector<std::vector<T>> B_T(n, std::vector<T>(p));
    for (size_t i = 0; i < p; ++i)
        for (size_t j = 0; j < n; ++j)
            B_T[j][i] = B[i][j];

    std::vector<std::vector<T>> res(m, std::vector<T>(n, T()));
    #pragma omp parallel for
    for (size_t i = 0; i < m; ++i) {
        for (size_t j = 0; j < n; ++j) {
            T sum = T();
            for (size_t k = 0; k < p; ++k) {
                sum += A[i][k] * B_T[j][k];
            }
            res[i][j] = sum;
        }
    }

    return res;
}
template<typename T>
std::vector<std::vector<T>> matpow(std::vector<std::vector<T>> A, long long n) {
    size_t size = A.size();
    std::vector<std::vector<T>> res(size, std::vector<T>(size, T()));
    for (size_t i = 0; i < size; ++i) {
        res[i][i] = T(1);
    }
    while (n > 0) {
        if (n & 1) {
            res = multiply(res, A);
        }
        A = multiply(A, A);
        n >>= 1;
    }
    return res;
}
//only for size small otherwise use template above
template<typename T, std::size_t N>
std::array<std::array<T, N>, N> multiply(const std::array<std::array<T, N>, N>& A, 
                                         const std::array<std::array<T, N>, N>& B) {
    std::array<std::array<T, N>, N> B_T = {};
    for (std::size_t i = 0; i < N; ++i)
        for (std::size_t j = 0; j < N; ++j)
            B_T[j][i] = B[i][j];

    std::array<std::array<T, N>, N> res = {};
    #pragma omp parallel for
    for (std::size_t i = 0; i < N; ++i) {
        for (std::size_t j = 0; j < N; ++j) {
            T sum = T();
            for (std::size_t k = 0; k < N; ++k) {
                sum += A[i][k] * B_T[j][k];
            }
            res[i][j] = sum;
        }
    }

    return res;
}
template<typename T, std::size_t N>
std::array<std::array<T, N>, N> matpow(std::array<std::array<T, N>, N> A, long long n) {
    std::array<std::array<T, N>, N> res = {};
    for (std::size_t i = 0; i < N; ++i) {
        res[i][i] = T(1);
    }
    while (n > 0) {
        if (n & 1) {
            res = multiply(res, A);
        }
        A = multiply(A, A);
        n >>= 1;
    }
    return res;
}


25)More NT
+Count prime

ll count_primes(ll N) { // count_primes(1e13) == 346065536839
    if (N <= 1) return 0;
    int sq = (int)sqrt(N);
    vl big_ans((sq+1)/2), small_ans(sq+1);
    FOR(i,1,sq+1) small_ans[i] = (i-1)/2;
    F0R(i,sz(big_ans)) big_ans[i] = (N/(2*i+1)-1)/2;
    vb skip(sq+1); int prime_cnt = 0;
    for (int p = 3; p <= sq; p += 2) if (!skip[p]) { // primes
        for (int j = p; j <= sq; j += 2*p) skip[j] = 1;
        F0R(j,min((ll)sz(big_ans),(N/p/p+1)/2)) {
            ll prod = (ll)(2*j+1)*p;
            big_ans[j] -= (prod > sq ? small_ans[(double)N/prod]
                         : big_ans[prod/2])-prime_cnt;
        }
        for (int j = sq, q = sq/p; q >= p; --q) for (;j >= q*p;--j) 
            small_ans[j] -= small_ans[q]-prime_cnt;
        ++prime_cnt;
    }
    return big_ans[0]+1;
}

+FPS
// Formal Power Series {{{
//
// Notes:
// - T must be ModInt

#include "NTT.h"
template<typename T> struct FormalPowerSeries : std::vector<T> {
    using std::vector<T>::vector;
    using P = FormalPowerSeries;

    // Remove zeroes at the end
    void shrink() {
        while (!this->empty() && this->back() == T(0)) this->pop_back();
    }

    // basic operators with another FPS: + - * / % {{{
    P operator + (const P& r) { return P(*this) += r; }
    P operator - (const P& r) { return P(*this) -= r; }
    P operator * (const P& r) { return P(*this) *= r; }

    P& operator += (const P& r) {
        if (r.size() > this->size()) this->resize(r.size());
        for (int i = 0; i < static_cast<int> (r.size()); ++i)
            (*this)[i] += r[i];
        shrink();
        return *this;
    }
    P& operator -= (const P& r) {
        if (r.size() > this->size()) this->resize(r.size());
        for (int i = 0; i < static_cast<int> (r.size()); ++i)
            (*this)[i] -= r[i];
        shrink();
        return *this;
    }
    P& operator *= (const P& r) {
        if (this->empty() || r.empty()) {
            this->clear();
        } else {
            auto res = multiply(*this, r);
            *this = P(res.begin(), res.end());
        }
        return *this;
    }
    // }}}
};
// }}}

+Fraction
// Fraction {{{
int cmp(int a, int b) { return (a == b) ? 0 : ((a < b) ? -1 : 1); }

struct Fraction {
    int a, b;

    Fraction() {
        a = 0;
        b = 1;
    }

    Fraction(int _a, int _b) {
        a = _a;
        b = _b;
        norm();
    }

    Fraction(int x) {
        a = x;
        b = 1;
    }

    Fraction operator + (const Fraction& other) const {
        return Fraction(a * other.b + b * other.a, b * other.b);
    }
    Fraction operator - (const Fraction& other) const {
        return Fraction(a * other.b - b * other.a, b * other.b);
    }
    Fraction operator * (const Fraction& other) const {
        return Fraction(a * other.a, b * other.b);
    }
    Fraction operator / (const Fraction& other) const {
        assert(other.a != 0);
        return Fraction(a * other.b, b * other.a);
    }

    int cmp(Fraction other) const {
        return ::cmp(a * other.b, b * other.a);
    }

#define Comp(x) bool operator x (Fraction q) const { return cmp(q) x 0; }
    Comp(>) Comp(<) Comp(==) Comp(>=) Comp(<=) Comp(!=)
#undef Comp

    void norm() {
        if (b < 0) {
            a = -a;
            b = -b;
        }

        if (a == 0) b = 1;
        else {
            int g = __gcd(llabs(a), llabs(b));
            a /= g;
            b /= g;
        }
    }
};
istream& operator >> (istream& cin, Fraction& p) {
    cin >> p.a;
    p.b = 1;
    return cin;
}
ostream& operator << (ostream& cout, Fraction& p) {
    cout << p.a << '/' << p.b;
    return cout;
}
// }}}


GEOMETRY
1)Point
#line 2 "geometry/geometry-base.hpp"

#include <algorithm>
#include <cassert>
#include <cmath>
#include <complex>
#include <iostream>
#include <vector>
using namespace std;

using Real = long double;
constexpr Real EPS = 1e-10;
constexpr Real pi = 3.141592653589793238462643383279L;
bool equals(Real a, Real b) { return fabs(b - a) < EPS; }
int sign(Real a) { return equals(a, 0) ? 0 : a > 0 ? 1 : -1; }

template <typename R>
struct PointBase {
  using P = PointBase;
  R x, y;
  PointBase() : x(0), y(0) {}
  PointBase(R _x, R _y) : x(_x), y(_y) {}
  template <typename T, typename U>
  PointBase(const pair<T, U>& p) : x(p.first), y(p.second) {}

  P operator+(const P& r) const { return {x + r.x, y + r.y}; }
  P operator-(const P& r) const { return {x - r.x, y - r.y}; }
  P operator*(R r) const { return {x * r, y * r}; }
  P operator/(R r) const { return {x / r, y / r}; }

  P& operator+=(const P& r) { return (*this) = (*this) + r; }
  P& operator-=(const P& r) { return (*this) = (*this) - r; }
  P& operator*=(R r) { return (*this) = (*this) * r; }
  P& operator/=(R r) { return (*this) = (*this) / r; }

  bool operator<(const P& r) const { return x != r.x ? x < r.x : y < r.y; }
  bool operator==(const P& r) const { return x == r.x and y == r.y; }
  bool operator!=(const P& r) const { return !((*this) == r); }

  P rotate(R rad) const {
    return {x * cos(rad) - y * sin(rad), x * sin(rad) + y * cos(rad)};
  }

  R real() const { return x; }
  R imag() const { return y; }
  friend R real(const P& p) { return p.x; }
  friend R imag(const P& p) { return p.y; }
  friend R dot(const P& l, const P& r) { return l.x * r.x + l.y * r.y; }
  friend R cross(const P& l, const P& r) { return l.x * r.y - l.y * r.x; }
  friend R abs(const P& p) { return sqrt(p.x * p.x + p.y * p.y); }
  friend R norm(const P& p) { return p.x * p.x + p.y * p.y; }
  friend R arg(const P& p) { return atan2(p.y, p.x); }

  friend istream& operator>>(istream& is, P& p) {
    R a, b;
    is >> a >> b;
    p = P{a, b};
    return is;
  }
  friend ostream& operator<<(ostream& os, const P& p) {
    return os << p.x << " " << p.y;
  }
};
using Point = PointBase<Real>;
using Points = vector<Point>;

// ccw, direction of the point
int ccw(const Point& a, const Point& b, const Point& c) {
  Point x = b - a, y = c - a;
  if (cross(x, y) > EPS) return +1;                 // Counterclockwise
  if (cross(x, y) < -EPS) return -1;                // Clockwise
  if (min(norm(x), norm(y)) < EPS * EPS) return 0;  // c=a or c=b
  if (dot(x, y) < EPS) return +2;                   // c-a-b in a straight line
  if (norm(x) < norm(y)) return -2;                 // a-b-c in a straight line
  return 0;                                         // a-c-b in a straight line
}


2)Polygon
#line 2 "geometry/polygon.hpp"

#line 2 "geometry/geometry-base.hpp"

#include <algorithm>
#include <cassert>
#include <cmath>
#include <complex>
#include <iostream>
#include <vector>
using namespace std;

using Real = long double;
constexpr Real EPS = 1e-10;
constexpr Real pi = 3.141592653589793238462643383279L;
bool equals(Real a, Real b) { return fabs(b - a) < EPS; }
int sign(Real a) { return equals(a, 0) ? 0 : a > 0 ? 1 : -1; }

template <typename R>
struct PointBase {
  using P = PointBase;
  R x, y;
  PointBase() : x(0), y(0) {}
  PointBase(R _x, R _y) : x(_x), y(_y) {}
  template <typename T, typename U>
  PointBase(const pair<T, U>& p) : x(p.first), y(p.second) {}

  P operator+(const P& r) const { return {x + r.x, y + r.y}; }
  P operator-(const P& r) const { return {x - r.x, y - r.y}; }
  P operator*(R r) const { return {x * r, y * r}; }
  P operator/(R r) const { return {x / r, y / r}; }

  P& operator+=(const P& r) { return (*this) = (*this) + r; }
  P& operator-=(const P& r) { return (*this) = (*this) - r; }
  P& operator*=(R r) { return (*this) = (*this) * r; }
  P& operator/=(R r) { return (*this) = (*this) / r; }

  bool operator<(const P& r) const { return x != r.x ? x < r.x : y < r.y; }
  bool operator==(const P& r) const { return x == r.x and y == r.y; }
  bool operator!=(const P& r) const { return !((*this) == r); }

  P rotate(R rad) const {
    return {x * cos(rad) - y * sin(rad), x * sin(rad) + y * cos(rad)};
  }

  R real() const { return x; }
  R imag() const { return y; }
  friend R real(const P& p) { return p.x; }
  friend R imag(const P& p) { return p.y; }
  friend R dot(const P& l, const P& r) { return l.x * r.x + l.y * r.y; }
  friend R cross(const P& l, const P& r) { return l.x * r.y - l.y * r.x; }
  friend R abs(const P& p) { return sqrt(p.x * p.x + p.y * p.y); }
  friend R norm(const P& p) { return p.x * p.x + p.y * p.y; }
  friend R arg(const P& p) { return atan2(p.y, p.x); }

  friend istream& operator>>(istream& is, P& p) {
    R a, b;
    is >> a >> b;
    p = P{a, b};
    return is;
  }
  friend ostream& operator<<(ostream& os, const P& p) {
    return os << p.x << " " << p.y;
  }
};
using Point = PointBase<Real>;
using Points = vector<Point>;

// ccw, counterclockwise direction of points
int ccw(const Point& a, const Point& b, const Point& c) {
  Point x = b - a, y = c - a;
  if (cross(x, y) > EPS) return +1;                 // Counterclockwise
  if (cross(x, y) < -EPS) return -1;                // Clockwise
  if (min(norm(x), norm(y)) < EPS * EPS) return 0;  // c=a or c=b
  if (dot(x, y) < EPS) return +2;                   // c-a-b are collinear
  if (norm(x) < norm(y)) return -2;                 // a-b-c are collinear
  return 0;                                         // a-c-b are collinear
}
#line 4 "geometry/polygon.hpp"

using Polygon = vector<Point>;

// Is the point inside the polygon?
// OUT: 0, ON: 1, IN: 2
int contains_polygon(const Polygon &Q, const Point &p) {
  bool in = false;
  for (int i = 0; i < (int)Q.size(); i++) {
    Point a = Q[i] - p, b = Q[(i + 1) % Q.size()] - p;
    if (imag(a) > imag(b)) swap(a, b);
    if (sign(imag(a)) <= 0 && 0 < sign(imag(b)) && sign(cross(a, b)) < 0)
      in = !in;
    if (equals(cross(a, b), 0) && sign(dot(a, b)) <= 0) return 1;
  }
  return in ? 2 : 0;
}

// Area of the polygon
Real area(const Polygon &p) {
  Real A = 0;
  for (int i = 0; i < (int)p.size(); ++i) {
    A += cross(p[i], p[(i + 1) % p.size()]);
  }
  return A * 0.5;
}

// Generate a convex hull from a set of vertices
// boundary: true if points on the boundary should also be included
template <bool boundary = false>
Polygon convex_hull(vector<Point> ps) {
  sort(begin(ps), end(ps));
  ps.erase(unique(begin(ps), end(ps)), end(ps));
  int n = ps.size(), k = 0;
  if (n <= 2) return ps;
  vector<Point> ch(2 * n);
  // Counterclockwise
  Real th = boundary ? -EPS : +EPS;
  for (int i = 0; i < n; ch[k++] = ps[i++]) {
    while (k >= 2 && cross(ch[k - 1] - ch[k - 2], ps[i] - ch[k - 1]) < th) --k;
  }
  for (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--]) {
    while (k >= t && cross(ch[k - 1] - ch[k - 2], ps[i] - ch[k - 1]) < th) --k;
  }
  ch.resize(k - 1);
  return ch;
}

// Is the point inside the convex hull?
// OUT: 0, ON: 1, IN: 2
int contains_convex(const Polygon &C, const Point &p) {
  int N = C.size();
  auto b1 = cross(C[1] - C[0], p - C[0]);
  auto b2 = cross(C[N - 1] - C[0], p - C[0]);
  if (b1 < -EPS or b2 > EPS) return 0;
  int L = 1, R = N - 1;
  while (L + 1 < R) {
    int M = (L + R) / 2;
    (cross(p - C[0], C[M] - C[0]) >= 0 ? R : L) = M;
  }
  auto v = cross(C[L] - p, C[R] - p);
  if (equals(v, 0)) {
    return 1;
  } else if (v > 0) {
    return equals(b1, 0) or equals(b2, 0) ? 1 : 2;
  } else {
    return 0;
  }
}

// Returns the pair of vertices that are the farthest apart on the convex hull
// Return value: pair of vertex indices
pair<int, int> convex_polygon_diameter(const Polygon &p) {
  int N = (int)p.size();
  int is = 0, js = 0;
  for (int i = 1; i < N; i++) {
    if (imag(p[i]) > imag(p[is])) is = i;
    if (imag(p[i]) < imag(p[js])) js = i;
  }
  Real maxdis = norm(p[is] - p[js]);

  int maxi, maxj, i, j;
  i = maxi = is;
  j = maxj = js;
  do {
    if (cross(p[(i + 1) % N] - p[i], p[(j + 1) % N] - p[j]) >= 0) {
      j = (j + 1) % N;
    } else {
      i = (i + 1) % N;
    }
    if (norm(p[i] - p[j]) > maxdis) {
      maxdis = norm(p[i] - p[j]);
      maxi = i;
      maxj = j;
    }
  } while (i != is || j != js);
  return minmax(maxi, maxj);
}


3)Line
#pragma once

#include "geometry-base.hpp"
#include "polygon.hpp"

struct Line {
  Point a, b;

  Line() = default;
  Line(const Point &_a, const Point &_b) : a(_a), b(_b) {}
  // Ax + By = C
  Line(const Real &A, const Real &B, const Real &C) {
    if (equals(A, 0)) {
      assert(!equals(B, 0));
      a = Point(0, C / B);
      b = Point(1, C / B);
    } else if (equals(B, 0)) {
      a = Point(C / A, 0);
      b = Point(C / A, 1);
    } else if (equals(C, 0)) {
      a = Point(0, C / B);
      b = Point(1, (C - A) / B);
    } else {
      a = Point(0, C / B);
      b = Point(C / A, 0);
    }
  }
  friend ostream &operator<<(ostream &os, const Line &l) {
    return os << l.a << " to " << l.b;
  }
  friend istream &operator>>(istream &is, Line &l) { return is >> l.a >> l.b; }
};
using Lines = vector<Line>;

bool is_parallel(const Line &a, const Line &b) {
  return equals(cross(a.b - a.a, b.b - b.a), 0);
}
bool is_orthogonal(const Line &a, const Line &b) {
  return equals(dot(a.a - a.b, b.a - b.b), 0);
}
Point cross_point_ll(const Line &l, const Line &m) {
  Real A = cross(l.b - l.a, m.b - m.a);
  Real B = cross(l.b - l.a, l.b - m.a);
  if (equals(abs(A), 0) && equals(abs(B), 0)) return m.a;
  return m.a + (m.b - m.a) * B / A;
}
bool is_intersect_ll(const Line &l, const Line &m) {
  Real A = cross(l.b - l.a, m.b - m.a);
  Real B = cross(l.b - l.a, l.b - m.a);
  if (equals(abs(A), 0) && equals(abs(B), 0)) return true;
  return !is_parallel(l, m);
}

// Intersection point when a perpendicular is dropped from the point to the line
Point projection(const Line &l, const Point &p) {
  Real t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);
  return l.a + (l.a - l.b) * t;
}

// Returns the part of the convex hull on the left side when cut by the line a -> b
Polygon convex_polygon_cut(const Polygon &U, const Line &l) {
  Polygon ret;
  for (int i = 0; i < (int)U.size(); i++) {
    const Point &now = U[i];
    const Point &nxt = U[(i + 1) % U.size()];
    auto cf = cross(l.a - now, l.b - now);
    auto cs = cross(l.a - nxt, l.b - nxt);
    if (sign(cf) >= 0) {
      ret.emplace_back(now);
    }
    if (sign(cf) * sign(cs) < 0) {
      ret.emplace_back(cross_point_ll(Line(now, nxt), l));
    }
  }
  return ret;
}


4)Segment
#pragma once

#include "geometry-base.hpp"
//
#include "line.hpp"

struct Segment : Line {
  Segment() = default;
  using Line::Line;
};

using Segments = vector<Segment>;

bool is_intersect_sp(const Segment &s, const Point &p) {
  return ccw(s.a, s.b, p) == 0;
}
bool is_intersect_ss(const Segment &s, const Segment &t) {
  return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&
         ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;
}

Real distance_sp(const Segment &s, const Point &p) {
  Point r = projection(s, p);
  if (is_intersect_sp(s, r)) return abs(r - p);
  return min(abs(s.a - p), abs(s.b - p));
}
Real distance_ss(const Segment &a, const Segment &b) {
  if (is_intersect_ss(a, b)) return 0;
  return min({distance_sp(a, b.a), distance_sp(a, b.b), distance_sp(b, a.a),
              distance_sp(b, a.b)});
}

5)Interger Geo
#line 2 "geometry/integer-geometry.hpp"

struct Point {
  using T = __int128_t;
  T x, y;
  Point() : x(0), y(0) {}
  Point(T x_, T y_) : x(x_), y(y_) {}

  Point &operator+=(const Point &p) {
    this->x += p.x;
    this->y += p.y;
    return *this;
  }

  Point &operator-=(const Point &p) {
    this->x -= p.x;
    this->y -= p.y;
    return *this;
  }

  int pos() const {
    if (y < 0) return -1;
    if (y == 0 && 0 <= x) return 0;
    return 1;
  }

  Point operator+(const Point &p) const { return Point(*this) += p; }
  Point operator-(const Point &p) const { return Point(*this) -= p; }
  Point operator-() const { return Point(-this->x, -this->y); }
  bool operator==(const Point &p) const { return x == p.x && y == p.y; }
  bool operator!=(const Point &p) const { return x != p.x || y != p.y; }
  bool operator<(const Point &p) const { return x == p.x ? y < p.y : x < p.x; }

  friend istream &operator>>(istream &is, Point &p) {
    long long x, y;
    is >> x >> y;
    p.x = x, p.y = y;
    return is;
  }

  friend ostream &operator<<(ostream &os, const Point &p) {
    os << (long long)(p.x) << " " << (long long)(p.y);
    return os;
  }
};
using Points = vector<Point>;

Point::T dot(const Point &a, const Point &b) { return a.x * b.x + a.y * b.y; }
Point::T cross(const Point &a, const Point &b) { return a.x * b.y - a.y * b.x; }

// sort by argument (-Pi ~ Pi)
void ArgumentSort(Points &v) {
  sort(begin(v), end(v), [](Point a, Point b) {
    if (a.pos() != b.pos()) return a.pos() < b.pos();
    return cross(a, b) > 0;
  });
}

// 1 ... counterclockwise / 0 straight / -1 clockwise
int ccw(const Point &a, const Point &b, const Point &c) {
  Point::T t = cross(b - a, c - a);
  return t < 0 ? -1 : t == 0 ? 0 : 1;
}

// v must have sorted by x-coordinate
Points LowerHull(const Points &ps) {
  int N = (int)ps.size();
  for (int i = 0; i < N - 1; i++) assert(ps[i].x <= ps[i + 1].x);
  if (N <= 2) return ps;
  Points convex(N);
  int k = 0;
  for (int i = 0; i < N; convex[k++] = ps[i++]) {
    while (k >= 2 && ccw(convex[k - 2], convex[k - 1], ps[i]) <= 0) --k;
  }
  convex.resize(k);
  return convex;
}

Points UpperHull(const Points &ps) {
  int N = (int)ps.size();
  for (int i = 0; i < N - 1; i++) assert(ps[i].x <= ps[i + 1].x);
  if (N <= 2) return ps;
  Points convex(N);
  int k = 0;
  for (int i = 0; i < N; convex[k++] = ps[i++]) {
    while (k >= 2 && ccw(convex[k - 2], convex[k - 1], ps[i]) >= 0) --k;
  }
  convex.resize(k);
  return convex;
}

Points ConvexHull(Points ps) {
  sort(begin(ps), end(ps));
  ps.erase(unique(begin(ps), end(ps)), end(ps));
  int N = ps.size();
  if (N <= 2) return ps;
  Points convex(2 * N);
  int k = 0;
  for (int i = 0; i < N; convex[k++] = ps[i++]) {
    while (k >= 2 && ccw(convex[k - 2], convex[k - 1], ps[i]) <= 0) --k;
  }
  for (int i = N - 2, t = k + 1; i >= 0; convex[k++] = ps[i--]) {
    while (k >= t && ccw(convex[k - 2], convex[k - 1], ps[i]) <= 0) --k;
  }
  convex.resize(k - 1);
  return convex;
}

6)3d Geo
// Quay điểm P quanh trục vector đơn vị (x,y,z) 1 góc a
// [ txx + c  | txy – sz | txz + sy ]
// [ txy + sz | tyy + c  | tyz – sx ]
// [ txz - sy | tyz + sx | tzz + c  ]
// Với: c = cos(a)      s = sin(a)      t = 1 – cos(a)

const double EPS = 1e-6;

inline double det(double a, double b, double c, double d) {
    return a * d - b * c;
}
struct Point {
    double x, y, z;
    
    Point() { x = y = z = 0; }
    Point(double x, double y, double z) : x(x), y(y), z(z) {}

    double length() {
        return sqrt(x * x + y * y + z * z);
    }
    Point operator * (double k) const { return Point(x*k, y*k, z*k); }

    double operator * (Point a) const { return x*a.x + y*a.y + z*a.z; }
    Point operator + (Point a) { return Point(x+a.x, y+a.y, z+a.z); }
    Point operator - (Point a) { return Point(x-a.x, y-a.y, z-a.z); }
    Point operator %(const Point &op) const {
        return Point(det(y, z, op.y, op.z), -det(x, z, op.x, op.z), det(x, y,
                op.x, op.y));
    }
};
struct Space {
    double a, b, c, d;
    Space(Point p0, Point p1, Point p2) {
        a = p0.y * (p1.z - p2.z) + p1.y * (p2.z - p0.z) + p2.y * (p0.z - p1.z);
        b = p0.z * (p1.x - p2.x) + p1.z * (p2.x - p0.x) + p2.z * (p0.x - p1.x);
        c = p0.x * (p1.y - p2.y) + p1.x * (p2.y - p0.y) + p2.x * (p0.y - p1.y);
        d = -p0.x * (p1.y * p2.z - p2.y * p1.z) - p1.x * (p2.y * p0.z - p0.y * p2.z) 
- p2.x * (p0.y * p1.z - p1.y * p0.z);
    }
};
Point projection(Point v, Point u) { // Chiếu vector v lên vector u
    double scalar = (v * u) / (u * u);
    return u * scalar;
}
Point projection(Point p, Point a, Point b, Point c) { // Chiếu điểm p lên mặt phẳng ABC
    Point u = (b - a) % (c - a), v = p - a;
    double scalar = (v * u) / (u * u);
    return p - (u * scalar);
}
double dist(Point p, Point a, Point b) { // Khoảng cách từ p tới đường thẳng AB
    p = p - a;
    Point proj = projection(p, b - a);
    return sqrt(p * p - proj * proj);
}
double area(Point a, Point b, Point c) { // Diện tích tam giác ABC
    double h = dist(a, b, c);
    return (h * (b - c).length()) / 2;
}
double volume(Point x, Point y, Point z) { // Thể tích của 3 vector 
    Point base = Point(y.y * z.z - y.z * z.y, y.z * z.x - y.x * z.z, y.x * z.y
            - y.y * z.x);
    return fabs(x.x * base.x + x.y * base.y + x.z * base.z) / 3;
}

// V - E + F = 2  |  E <= 3V – 6  |  F <= 2V - 4

// 3d convex hull
inline int sign(double x) { return x < -EPS ? -1 : x > EPS ? 1 : 0; }
vector<Point> arr;
vector<int> rnd;
set<int> used;

typedef vector<int> Side;
Side getFirstSide(vector<Point> &p) {
    int i1 = 0;
    REP(i,p.size()) {
        if (p[i].z < p[i1].z || (p[i].z == p[i1].z && p[i].x < p[i1].x)
                || (p[i].z == p[i1].z && p[i].x == p[i1].x && p[i].y < p[i1].y)) {
            i1 = i;
        }
    }
    int i2 = i1 == 0 ? 1 : 0;
    REP(i,p.size()) {
        if (i != i1) {
            Point zDir(0, 0, 1);
            double curCos = (p[i] - p[i1]) * zDir / (p[i] - p[i1]).length();
            double bestCos = (p[i2] - p[i1]) * zDir / (p[i2] - p[i1]).length();
            if (curCos < bestCos) {
                i2 = i;
            }
        }
    }
    int i3 = -1;
    int n = p.size();
    REP(ri,n) {
        int i = rnd[ri];
        if (i != i1 && i != i2) {
            Point norm = (p[i1] - p[i]) % (p[i2] - p[i]);
            bool sg[] = { 0, 0, 0 };
            REP(t,n) {
                int j = rnd[t];
                sg[1 + sign((p[j] - p[i]) * norm)] = true;
                if (sg[0] && sg[2]) {
                    break;
                }
            }
            if (sg[0] ^ sg[2]) {
                i3 = i;
                if (!sg[0]) {
                    swap(i3, i2);
                }
                break;
            }
        }
    }
    vector<int> res;
    res.push_back(i1);
    res.push_back(i2);
    res.push_back(i3);
    return res;
}

inline int getSideKey(int i, int j, int k) {
    int key = (i * 1000 + j) * 1000 + k;
    return key;
}
inline bool isUsed(int i, int j, int k) {
    return used.find(getSideKey(i, j, k)) != used.end();
}

inline double getAngle(const Point &n1, const Point &n2) {
    return atan2((n1 % n2).length(), n1 * n2);
}

inline double getNormsAngle(int i, int j, int k, int t, vector<Point> &p) {
    Point n1 = (p[j] - p[i]) % (p[k] - p[i]);
    Point n2 = (p[t] - p[i]) % (p[j] - p[i]);
    return getAngle(n1, n2);
}

void dfs(int i, int j, int k, vector<Point> &p, vector<Side> &sides) {
    if (i < j && i < k) {
        vector<int> side(3);
        side[0] = i;
        side[1] = j;
        side[2] = k;
        sides.push_back(side);
    }
    int key = getSideKey(i, j, k);
    used.insert(key);
    int n = p.size();
    if (!isUsed(j, k, i))
        dfs(j, k, i, p, sides);
    if (!isUsed(k, i, j))
        dfs(k, i, j, p, sides);

    int bestT = -1;
    double bestAngle = 1e20;
    Point curNorm = (p[j] - p[i]) % (p[k] - p[i]);
    Point dir = p[j] - p[i];
    REP(t,n) {
        if (t != i && t != j && t != k) {
            Point newNorm = (p[t] - p[i]) % dir;
            double curAng = curNorm * newNorm / newNorm.length();
            if (bestT == -1 || curAng > bestAngle) {
                bestT = t;
                bestAngle = curAng;
            }
        }
    }
    if (!isUsed(i, bestT, j)) {
        dfs(i, bestT, j, p, sides);
    }
}
vector<Side> convexHull3d(vector<Point> p) {
    used.clear();
    rnd.resize(p.size());
    REP(i,p.size())
        rnd[i] = i;
    random_shuffle(rnd.begin(), rnd.end());
    Side side0 = getFirstSide(p);
    vector<Side> sides;

    dfs(side0[0], side0[1], side0[2], p, sides);
    return sides;
}

/* eliminate conflict sides */
inline bool isEmpty(Point x, Point y, Point z) {
    return abs(x * Point(y.y * z.z - y.z * z.y, y.z * z.x - y.x * z.z, y.x
            * z.y - y.y * z.x)) <= EPS;
}
inline bool conflict(Side a, Side b) {
    Point x = arr[a[0]], y = arr[a[1]], z = arr[a[2]];
    REP(i,3) {
        Point t = arr[b[i]];
        if (!isEmpty(x - t, y - t, z - t))
            return false;
    }
    return true;
}
vector<Side> eliminate(vector<Side> p) {
    vector<Side> res;
    vector<bool> fre;
    fre.resize(p.size(), true);
    REP(i,p.size()) {
        if (!fre[i])
            continue;
        res.push_back(p[i]);
        FOR(j,i+1,p.size() - 1)
            if (fre[j]) {
                if (conflict(p[i], p[j])) {
                    fre[j] = false;
                    res.back().insert(res.back().end(), p[j].begin(),
                            p[j].end());
                }
            }
    }
    REP(i,res.size()) {
        sort(res[i].begin(), res[i].end());
        res[i].resize(unique(res[i].begin(), res[i].end()) - res[i].begin());
    }
    return res;
}
// End of 3d convex hull

7)Circle
template <class T> int sgn(T x) { return (x > 0) - (x < 0); }
template<class T>
struct Point {
    typedef Point P;
    T x, y;
    explicit Point(T x=0, T y=0) : x(x), y(y) {}
    bool operator<(P p) const { return tie(x,y) < tie(p.x,p.y); }
    bool operator==(P p) const { return tie(x,y)==tie(p.x,p.y); }
    P operator+(P p) const { return P(x+p.x, y+p.y); }
    P operator-(P p) const { return P(x-p.x, y-p.y); }
    P operator*(T d) const { return P(x*d, y*d); }
    P operator/(T d) const { return P(x/d, y/d); }
    T dot(P p) const { return x*p.x + y*p.y; }
    T cross(P p) const { return x*p.y - y*p.x; }
    T cross(P a, P b) const { return (a-*this).cross(b-*this); }
    T dist2() const { return x*x + y*y; }
    double dist() const { return sqrt((double)dist2()); }
    // angle to x-axis in interval [-pi, pi]
    double angle() const { return atan2(y, x); }
    P unit() const { return *this/dist(); } // makes dist()=1
    P perp() const { return P(-y, x); } // rotates +90 degrees
    P normal() const { return perp().unit(); }
    // returns point rotated 'a' radians ccw around the origin
    P rotate(double a) const {
        return P(x*cos(a)-y*sin(a),x*sin(a)+y*cos(a)); }
    friend ostream& operator<<(ostream& os, P p) {
        return os << "(" << p.x << "," << p.y << ")"; }
};
/*
Computes the pair of points at which two circles intersect.
 Returns false in case of no intersection.
*/
typedef Point<double> P;
bool circleInter(P a,P b,double r1,double r2,pair<P, P>* out) {
    if (a == b) { assert(r1 != r2); return false; }
    P vec = b - a;
    double d2 = vec.dist2(), sum = r1+r2, dif = r1-r2,
           p = (d2 + r1*r1 - r2*r2)/(d2*2), h2 = r1*r1 - p*p*d2;
    if (sum*sum < d2 || dif*dif > d2) return false;
    P mid = a + vec*p, per = vec.perp() * sqrt(fmax(0, h2) / d2);
    *out = {mid + per, mid - per};
    return true;
}
//Finds the intersection between a circle and a line.
template<class P>
vector<P> circleLine(P c, double r, P a, P b) {
    P ab = b - a, p = a + ab * (c-a).dot(ab) / ab.dist2();
    double s = a.cross(b, c), h2 = r*r - s*s / ab.dist2();
    if (h2 < 0) return {};
    if (h2 == 0) return {p};
    P h = ab.unit() * sqrt(h2);
    return {p - h, p + h};
}
//Returns the area of the intersection of a circle with a ccw polygon.
typedef Point<double> P;
#define arg(p, q) atan2(p.cross(q), p.dot(q))
double circlePoly(P c, double r, vector<P> ps) {
    auto tri = [&](P p, P q) {
        auto r2 = r * r / 2;
        P d = q - p;
        auto a = d.dot(p)/d.dist2(), b = (p.dist2()-r*r)/d.dist2();
        auto det = a * a - b;
        if (det <= 0) return arg(p, q) * r2;
        auto s = max(0., -a-sqrt(det)), t = min(1., -a+sqrt(det));
        if (t < 0 || 1 <= s) return arg(p, q) * r2;
        P u = p + d * s, v = p + d * t;
        return arg(p,u) * r2 + u.cross(v)/2 + arg(v,q) * r2;
    };
    auto sum = 0.0;
    rep(i,0,sz(ps))
        sum += tri(ps[i] - c, ps[(i + 1) % sz(ps)] - c);
    return sum;
}
/*
 * Description: Finds the external tangents of two circles, or internal if r2 is negated.
 * Can return 0, 1, or 2 tangents -- 0 if one circle contains the other (or overlaps it, in the internal case, or if the circles are the same);
 * 1 if the circles are tangent to each other (in which case .first = .second and the tangent line is perpendicular to the line between the centers).
 * .first and .second give the tangency points at circle 1 and 2 respectively.
 * To find the tangents of a circle with a point set r2 to 0.
*/
template<class P>
vector<pair<P, P>> tangents(P c1, double r1, P c2, double r2) {
    P d = c2 - c1;
    double dr = r1 - r2, d2 = d.dist2(), h2 = d2 - dr * dr;
    if (d2 == 0 || h2 < 0)  return {};
    vector<pair<P, P>> out;
    for (double sign : {-1, 1}) {
        P v = (d * dr + d.perp() * sqrt(h2) * sign) / d2;
        out.push_back({c1 + v * r1, c2 + v * r2});
    }
    if (h2 == 0) out.pop_back();
    return out;
}

ADDITIONAL CODE:

1)2D prefix sum
vector<int> buildPrefixSum(const vector<int>& a, int C = 0) {
    int n = (int)a.size();
    vector<int> prefixSum(n + 1);

    prefixSum[0] = C;

    for (int i = 0; i < n; i++)
        prefixSum[i + 1] = prefixSum[i] + a[i];

    return prefixSum;
}

//or use partial_sum(first, last, result, binary_op)

//2d prefix sum
template <typename T>
vector<vector<T>> prefixSum2D(const vector<vector<T>>& matrix) {
    int n = matrix.size();
    if (n == 0) return {};
    int m = matrix[0].size();
    vector<vector<T>> prefixSum(n,vector<T>(m, 0));
    
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < m; ++j) {
            prefixSum[i][j] = matrix[i][j] 
                            + (i > 0 ? prefixSum[i-1][j] : 0) 
                            + (j > 0 ? prefixSum[i][j-1] : 0) 
                            - (i > 0 && j > 0 ? prefixSum[i-1][j-1] : 0);
        }
    }
    return prefixSum;
}

2)Lucas theorem
/*
   First calculate first 1001 factorial number to faster calculate
   Example block_size=1000, max_blocks=1001;
*/
vll compute_pre_fact(ull m, int block_size, int max_blocks){
    vll pre_fact(max_blocks + 1, 1);
    for(int i = 1; i <= max_blocks; i++){
        pre_fact[i] = pre_fact[i-1];
        for(int j = 1; j <= block_size; j++){
            ull current = (i-1) * block_size + j;
            pre_fact[i] = modmul(pre_fact[i], current, m);
        }
    }
    return pre_fact;
}
struct Barrett {
    using u32 = unsigned int;
    using i64 = long long;
    using u64 = unsigned long long;
    u32 m;
    u64 im;
    Barrett() : m(), im() {}
    Barrett(int n) : m(n), im(u64(-1) / m + 1) {}
    constexpr inline i64 quo(u64 n) {
        u64 x = u64((__uint128_t(n) * im) >> 64);
        u32 r = n - x * m;
        return m <= r ? x - 1 : x;
    }
    constexpr inline i64 rem(u64 n) {
        u64 x = u64((__uint128_t(n) * im) >> 64);
        u32 r = n - x * m;
        return m <= r ? r + m : r;
    }
    constexpr inline pair<i64, int> quorem(u64 n) {
        u64 x = u64((__uint128_t(n) * im) >> 64);
        u32 r = n - x * m;
        if (m <= r) return {x - 1, r + m};
        return {x, r};
    }
    constexpr inline i64 pow(u64 n, i64 p) {
        u32 a = rem(n), r = m == 1 ? 0 : 1;
        while (p) {
            if (p & 1) r = rem(u64(r) * a);
            a = rem(u64(a) * a);
            p >>= 1;
        }
        return r;
    }
    constexpr inline u32 mul(u32 a, u32 b) {
        return rem(u64(a) * b);
    }
};
ull modmul(ull a, ull b, ull m){
    Barrett br(m);
    return br.mul(a, b);
}

ull modpow(ull b, ull e, ull mod) {
    ull ans = 1;
    for (; e; b = modmul(b, b, mod), e /= 2)
        if (e & 1) ans = modmul(ans, b, mod);
    return ans;
}
#include<number_theory/mod_inv>
ull factorial(ull n, const vll& pre_fact, ull m){
    const int BLOCK_SIZE = 1000; // Adjust block size as needed
    if (n < BLOCK_SIZE) {
        ull prod = 1;
        for (ll i = 1; i <= n; i++) {
            prod = modmul(prod, i, m);
        }
        return prod;
    } else {
        ull cur = n / BLOCK_SIZE;
        ull res = pre_fact[cur];
        for (ll i = cur * BLOCK_SIZE + 1; i <= n; i++) {
            res = modmul(res, i, m);
        }
        return res;
    }
}
ull C(ull n, ull k, const vll& pre_fact, ull m){
   if(k > n) return 0;
   ull nu = factorial(n, pre_fact, m);
   ull de = modmul(factorial(k, pre_fact, m), factorial(n - k, pre_fact, m), m);
   return modmul(nu, inv_mod(de, m), m);
}

ull lucas(ull n, ull k, const vll& pre_fact, ull m){
  if(k == 0) return 1;
  ull ni = n % m;
  ull ki = k % m;
  return modmul(C(ni, ki, pre_fact, m), lucas(n / m, k / m, pre_fact, m), m);
}


3)Fenwick 2d
#include "FenwickTree.h"

struct FT2 {
    vector<vi> ys; vector<FT> ft;
    FT2(int limx) : ys(limx) {}
    void fakeUpdate(int x, int y) {
        for (; x < sz(ys); x |= x + 1) ys[x].push_back(y);
    }
    void init() {
        for (vi& v : ys) sort(all(v)), ft.emplace_back(sz(v));
    }
    int ind(int x, int y) {
        return (int)(lower_bound(all(ys[x]), y) - ys[x].begin()); }
    void update(int x, int y, ll dif) {
        for (; x < sz(ys); x |= x + 1)
            ft[x].update(ind(x, y), dif);
    }
    ll query(int x, int y) {
        ll sum = 0;
        for (; x; x &= x - 1)
            sum += ft[x-1].query(ind(x-1, y));
        return sum;
    }
};

4)LIS
template<class I> vi lis(const vector<I>& S) {
    if (S.empty()) return {};
    vi prev(sz(S));
    typedef pair<I, int> p;
    vector<p> res;
    rep(i,0,sz(S)) {
        // change 0 -> i for longest non-decreasing subsequence
        auto it = lower_bound(all(res), p{S[i], 0});
        if (it == res.end()) res.emplace_back(), it = res.end()-1;
        *it = {S[i], i};
        prev[i] = it == res.begin() ? 0 : (it-1)->second;
    }
    int L = sz(res), cur = res.back().second;
    vi ans(L);
    while (L--) ans[L] = cur, cur = prev[cur];
    return ans;
}

5)LCS
// source: http://www.secmem.org/blog/2019/09/12/lcs-with-bitset/
// bitset optimization of LCS dp
// res[i]: length of the LCS of s[0:i) and t
// O(n m / w) time
// O(n + m lim / w) space
template<class Str, int lim = 26>
vector<int> longest_common_subsequence_lengths(const Str &s, const Str &t, function<int(int)> convert = [](int c){ return c - 'a'; }){
    int n = (int)s.size(), m = (int)t.size(), sz = (m >> 6) + 1;
    using mask_type = unsigned long long;
    array<vector<mask_type>, lim> masks;
    masks.fill(vector<mask_type>(sz));
    for(auto j = 0; j < m; ++ j) masks[convert(t[j])][j >> 6] |= 1ull << (j & 63);
    vector<mask_type> dp(sz);
    vector<int> res(n + 1);
    for(auto j = 0; j < m; ++ j) if(convert(s[0]) == convert(t[j])){
        dp[j >> 6] |= 1ull << (j & 63);
        res[1] = 1;
        break;
    }
    for(auto i = 1; i < n; ++ i){
        auto &mask = masks[convert(s[i])];
        mask_type shl_carry = 1, minus_carry = 0;
        for(auto k = 0; k < sz; k++){
            mask_type x_k = mask[k] | dp[k];
            mask_type term_1 = dp[k] << 1 | shl_carry;
            shl_carry = dp[k] >> 63;
            auto sub_carry = [](mask_type &x, mask_type y){
                mask_type tmp = x;
                return (x = tmp - y) > tmp;
            };
            mask_type term_2 = x_k;
            minus_carry = sub_carry(term_2, minus_carry);
            minus_carry += sub_carry(term_2, term_1);
            dp[k] = x_k & (x_k ^ term_2);
        }
        dp[m >> 6] &= (1llu << (m & 63)) - 1;
        res[i + 1] = accumulate(dp.begin(), dp.end(), 0, [&](int sum, auto y){ return sum + __builtin_popcountll(y); });
    }
    return res;
}
 
// Hirschburg's space optimization of LCS dp
// O(n m / w) time (with about twice the constant factor)
// O(n + m + lim * m / w) space
// Requires longest_common_subsequence_lengths
template<class Str, int lim = 26>
Str longest_common_subsequence(const Str &s, const Str &t, function<int(int)> convert = [](int c){ return c - 'a'; }){
    if(s.empty() || t.empty()) return {};
    int n = (int)s.size(), m = (int)t.size();
    Str res;
    function<void(int, int, int, int)> solve = [&](int il, int ir, int jl, int jr){
        if(jr - jl == 1){
            for(auto p = il; p < ir; ++ p) if(s[p] == t[jl]){
                res.push_back(s[p]);
                return;
            }
            return;
        }
        int jm = jl + (jr - jl >> 1);
        auto dp_left = longest_common_subsequence_lengths<Str, lim>({s.begin() + il, s.begin() + ir}, {t.begin() + jl, t.begin() + jm}, convert);
        auto dp_right = longest_common_subsequence_lengths<Str, lim>({s.rend() - ir, s.rend() - il}, {t.rend() - jr, t.rend() - jm}, convert);
        array<int, 2> pos{dp_left[0] + dp_right[ir - il], 0};
        for(auto l = 1; l <= ir - il; ++ l) pos = max(pos, array{dp_left[l] + dp_right[ir - il - l], l});
        int im = pos[1] + il;
        solve(il, im, jl, jm), solve(im, ir, jm, jr);
    };
    solve(0, n, 0, m);
    return res;
}

6)Debug
void __print(int x) {cerr << x;}
void __print(long x) {cerr << x;}
void __print(long long x) {cerr << x;}
void __print(unsigned x) {cerr << x;}
void __print(unsigned long x) {cerr << x;}
void __print(unsigned long long x) {cerr << x;}
void __print(float x) {cerr << x;}
void __print(double x) {cerr << x;}
void __print(long double x) {cerr << x;}
void __print(char x) {cerr << '\'' << x << '\'';}
void __print(const char *x) {cerr << '\"' << x << '\"';}
void __print(const string &x) {cerr << '\"' << x << '\"';}
void __print(bool x) {cerr << (x ? "true" : "false");}

template<typename T, typename V>
void __print(const pair<T, V> &x) {cerr << '{'; __print(x.first); cerr << ", "; __print(x.second); cerr << '}';}
template<typename T>
void __print(const T &x) {int f = 0; cerr << '{'; for (auto it = std::begin(x); it != std::end(x); ++it)  cerr << (f++ ? ", " : ""), __print(*it); cerr << "}";}
void _print() {cerr << "]\n";}
template <typename T, typename... V>
void _print(T t, V... v) {__print(t); if (sizeof...(v)) cerr << ", "; _print(v...);}

void dbg_out() { cerr << endl; }
template<typename Head, typename... Tail> void dbg_out(Head H, Tail... T) { __print(H); if (sizeof...(T)) cerr << ", "; dbg_out(T...); }
#define dbg(...) cerr << "[" << #__VA_ARGS__ << "]:"; dbg_out(_VA_ARGS_);

7) Divisor:
#line 1 "math/number-theory/divisor.hpp"
vector<int64_t> divisor(int64_t n) {
  vector<int64_t> ret;
  for (int64_t i = 1; i * i <= n; i++) {
    if (n % i == 0) {
      ret.push_back(i);
      if (i * i != n) ret.push_back(n / i);
    }
  }
  sort(begin(ret), end(ret));
  return ret;
}


8)Sum of totient
template <typename T, int LG = 20, bool KEEP_IS = false>
struct HashMap {
    static const u64 FIXED_RANDOM;
    static constexpr int N = 1 << LG;
    u64* key = new u64[N];
    T* val = new T[N];
    vi IS;
    std::bitset<N> vis;
    static u32 hash(u64 x) { return (u64(x + FIXED_RANDOM) * 11995408973635179863ULL) >> (64 - LG); }
    int index(u64 k) const {
        int i = hash(k);
        while (vis[i] && key[i] != k)
            i = (i + 1) & (N - 1);
        return i;
    }
    T& operator[](u64 k) {
        int i = index(k);
        if (!vis[i]) {
            vis[i] = true;
            key[i] = k;
            val[i] = {};
            if constexpr (KEEP_IS)
                IS.eb(i);
        }
        return val[i];
    }
    T get(u64 k, T d = {}) const {
        int i = index(k);
        return vis[i] ? val[i] : d;
    }
    bool contains(u64 k) const {
        int i = index(k);
        return vis[i] && key[i] == k;
    }
    void clear() {
        vis.reset();
        if constexpr (KEEP_IS)
            IS.clear();
    }
    void enumerate(auto&& f) const {
        static_assert(KEEP_IS);
        for(auto i: IS)
            f(key[i], val[i]);
    }
    ~HashMap() {
        delete[] key;
        delete[] val;
    }
};
template <typename T, int LG, bool KEEP_IS>
const u64 HashMap<T, LG, KEEP_IS>::FIXED_RANDOM = std::chrono::steady_clock::now().time_since_epoch().count();
HashMap<ll>dp;
//(sum from i=1 to n)ϕ(i)
ll sum_of_totient(ll n){
    if(n==0) return 0;
    if(n==1) return 1;
    if(dp.contains(n)) return dp[n];
    ll res=n%MOD*((n+1)%MOD)%MOD*499122177 % MOD;
    ll i=2;
    while(i<=n){
        ll ni=n/i;
        ll nxt=n/ni+1;
        ll cnt=(nxt-i)%MOD;
        res=(res-sum_of_totient(ni)*cnt%MOD+MOD)%MOD;
        i=nxt;
    }
    dp[n]=res;
    return res;
}

9)Continued fractions
typedef double d; // Use double for N ~ 1e7; long double for N ~ 1e9

// Function to find the closest rational approximation of a real number x with p, q <= N
pair<ll, ll> approximate(d x, ll N) {
    ll LP = 0, LQ = 1, P = 1, Q = 0; // Initialize previous and current numerators (LP, P) and denominators (LQ, Q)
    ll inf = LLONG_MAX;              // Large constant to use as a limit
    d y = x;                         // Store the input number in y, which will be refined in the loop

    for (;;) {                       // Infinite loop to find the best approximation
        // Calculate the limits for how much we can multiply current numerators and denominators
        ll lim = min(P ? (N-LP) / P : inf, Q ? (N-LQ) / Q : inf);

        // Extract the integer part of y (floor of y)
        ll a = (ll)floor(y);

        // Set b as the minimum of a and the limit, ensuring the numerator and denominator stay <= N
        ll b = min(a, lim);

        // Calculate the next numerator and denominator for the fraction
        ll NP = b * P + LP, NQ = b * Q + LQ;

        // If the integer part (a) is greater than the limit (b), we check for semi-convergents
        if (a > b) {
            // Semi-convergent check: if b > a/2, the semi-convergent can be a better approximation
            // If the new fraction NP/NQ is closer to x than the current fraction P/Q, return it
            return (abs(x - (d)NP / (d)NQ) < abs(x - (d)P / (d)Q)) ?
                   make_pair(NP, NQ) : make_pair(P, Q);
        }

        // Update y with the next term in the continued fraction expansion (reciprocal of the fractional part)
        if (abs(y = 1 / (y - (d)a)) > 3 * N) { 
            // If the next term is too large, stop and return the current approximation
            return {NP, NQ};
        }

        // Move to the next convergent: update the previous terms and set P, Q to the new ones
        LP = P; P = NP;
        LQ = Q; Q = NQ;
    }
}


10) Template
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define For(i,a,b) for (int i=(a); i<(b); i++)
#define rep(i,a) For(i,0,a)
#define rev(i,a,b) for (int i=(a); i>(b); i--)
#define FOR(i,a,b) for (int i=(a); i<=(b); i++)
#define REP(i,a) FOR(i,1,a)
#define REV(i,a,b) for (int i=(a); i>=(b); i--)
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
int main(){
     ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);

}

11) Bit hacks
namespace kiffazbit{
inline int Abs(int n) {return (n ^ (n >> 31)) - (n >> 31);}
inline int max(int a, int b) { return (b & ((a - b) >> 31)) | (a & (~(a - b) >> 31));}
inline int min(int a, int b) { return (a & ((a - b) >> 31)) | (b & (~(a - b) >> 31));}
bool isSameSign(int x, int y) {return (x ^ y) >= 0;}
void swap(int &a, int &b) { a ^= b ^= a ^= b;}
inline int getBit(int a, int b) { return (a >> b) & 1; }
inline int unsetBit(int a, int b) { return a & ~(1 << b); }
inline int setBit(int a, int b) { return a | (1 << b); }
inline int flapBit(int a, int b) { return a ^ (1 << b); }
inline int lsb(const u64 &a) { return a ? __builtin_ctzll(a) : 64; } // Index of the least significant bit set, or 64 if a is zero.
inline int ctz(const u64 &a) { return a ? __builtin_ctzll(a) : 64; } // Count of trailing zero bits, or 64 if a is zero.
inline int msb(const u64 &a) { return a ? 63 - __builtin_clzll(a) : -1; } // Index of the most significant bit set, or -1 if a is zero.
int popcnt(int x) { return __builtin_popcount(x); }
int popcnt(ll x) { return __builtin_popcountll(x); }
#define MASK(b, k) (((b) >> (k)) & 1)
inline int ceil_pow2(int n) {
    int x = 0;
    while ((1U << x) < (unsigned int)(n)) x++;
    return x;
} // ->x (2^x>=n)
} //namespace kiffazbit

//for(int x=m;x;){--x&=m;...} loops over all subset masks of m(except m itself)
//c=x&-x,r=x+c; (((r^x)>>2)/c)|r is the next number after x with the same number of bits set
//rep(b,K) rep(i,(1<<K)) if(i&1<<b) D[i]+=D[i^(1<<b)] compute all sum of subsets


12)Compress
template< typename T >
struct Compress {
  vector< T > xs;

  Compress() = default;

  Compress(const vector< T > &vs) {
    add(vs);
  }

  Compress(const initializer_list< vector< T > > &vs) {
    for(auto &p : vs) add(p);
  }

  void add(const vector< T > &vs) {
    copy(begin(vs), end(vs), back_inserter(xs));
  }
  void add(const T &x) {
    xs.emplace_back(x);
  }

  void build() {
    sort(begin(xs), end(xs));
    xs.erase(unique(begin(xs), end(xs)), end(xs));
  }

  vector< int > get(const vector< T > &vs) const {
    vector< int > ret;
    transform(begin(vs), end(vs), back_inserter(ret), [&](const T &x) {
      return lower_bound(begin(xs), end(xs), x) - begin(xs);
    });
    return ret;
  }

  int get(const T &x) const {
    return lower_bound(begin(xs), end(xs), x) - begin(xs);
  }

  const T &operator[](int k) const {
    return xs[k];
  }
};


13)Left-Right nearest smaller
// return:
// - left[i] = largest j such that
//      j < i
//      a[j] < a[i]
// - no such j -> left[i] = -1
vector<int> leftNearestSmaller(const vector<int>& a) {
    int n = a.size();
    vector<int> left(n);
    stack<int> st;  // positions of candidates, A is increasing
    st.push(-1);
    for (int i = 0; i < n; i++) {
        while (st.top() >= 0 && a[st.top()] >= a[i]) st.pop();
        left[i] = st.top();
        st.push(i);
    }
    return left;
}

// return:
// - right[i] = smallest j such that:
//      j > i
//      a[j] < a[i]
// - no such j -> right[i] = n
vector<int> rightNearestSmaller(const vector<int>& a) {
    int n = a.size();
    vector<int> right(n);
    stack<int> st;   // positions of candidates, A is increasing
    st.push(n);
    for (int i = n-1; i >= 0; i--) {
        while (st.top() < n && a[st.top()] >= a[i]) st.pop();
        right[i] = st.top();
        st.push(i);                                      
    }
    return right;
}
